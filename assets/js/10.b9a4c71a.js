(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{423:function(e,t,v){"use strict";v.r(t);var _=v(18),i=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"一文吃透react高阶组件hoc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一文吃透react高阶组件hoc"}},[e._v("#")]),e._v(" 一文吃透React高阶组件HOC")]),e._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ"),v("OutboundLink")],1)])]),e._v(" "),v("h1",{attrs:{id:"一-前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-前言"}},[e._v("#")]),e._v(" 一 前言")]),e._v(" "),v("p",[v("code",[e._v("React")]),e._v("高阶组件("),v("code",[e._v("HOC")]),e._v(")，对于很多"),v("code",[e._v("react")]),e._v("开发者来说并不陌生，它是灵活使用"),v("code",[e._v("react")]),e._v("组件的一种技巧，高阶组件本身不是组件，它是一个参数为组件，返回值也是一个组件的函数。高阶作用用于"),v("strong",[e._v("强化组件，复用逻辑，提升渲染性能等")]),e._v("作用。高阶组件也并不是很难理解，其实接触过后还是蛮简单的，接下来我将按照，"),v("strong",[e._v("高阶组件理解？")]),e._v("，"),v("strong",[e._v("高阶组件具体怎么使用？应用场景")]),e._v("， "),v("strong",[e._v("高阶组件实践(源码级别)")]),e._v(" 为突破口，带大家详细了解一下高阶组件。本文篇幅比较长，建议收藏观看")]),e._v(" "),v("p",[e._v("我们带着问题去开始今天的讨论：")]),e._v(" "),v("ul",[v("li",[e._v("1 什么是高阶组件，它解决了什么问题？")]),e._v(" "),v("li",[e._v("2 有几种高阶组件，它们优缺点是什么？")]),e._v(" "),v("li",[e._v("3 如何写一个优秀高阶组件？")]),e._v(" "),v("li",[e._v("4 "),v("code",[e._v("hoc")]),e._v("怎么处理静态属性，跨层级"),v("code",[e._v("ref")]),e._v("等问题？")]),e._v(" "),v("li",[e._v("5 高阶组件怎么控制渲染，隔离渲染？")]),e._v(" "),v("li",[e._v("6 高阶组件怎么监控原始组件的状态？")]),e._v(" "),v("li",[e._v("...")])]),e._v(" "),v("blockquote",[v("p",[e._v("高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXvHqmbKib3PNgQiaxiaJ5dZYicz6nNNIzJR8beFsTUbDcvrh8hxSYMFGQXw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),v("h1",{attrs:{id:"二-全方位看高阶组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-全方位看高阶组件"}},[e._v("#")]),e._v(" 二 全方位看高阶组件")]),e._v(" "),v("h2",{attrs:{id:"_1-几种包装强化组件的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-几种包装强化组件的方式"}},[e._v("#")]),e._v(" 1 几种包装强化组件的方式")]),e._v(" "),v("h3",{attrs:{id:"_1-mixin模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mixin模式"}},[e._v("#")]),e._v(" ① mixin模式")]),e._v(" "),v("p",[v("strong",[e._v("原型图")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXFKuSNPhezUhs2TNsfnfIjmeqFfqQdM6zcOxANCuNEcBwAaR928UtsQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),v("h4",{attrs:{id:"老版本的react-mixins"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#老版本的react-mixins"}},[e._v("#")]),e._v(" 老版本的"),v("code",[e._v("react-mixins")])]),e._v(" "),v("p",[e._v("在"),v("code",[e._v("react")]),e._v("初期提供一种组合方法。通过"),v("code",[e._v("React.createClass")]),e._v(",加入"),v("code",[e._v("mixins")]),e._v("属性，具体用法和"),v("code",[e._v("vue")]),e._v(" 中"),v("code",[e._v("mixins")]),e._v("相似。具体实现如下。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const customMixin = {  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}\nconst APP = React.createClass({  mixins: [ customMixin ],  getInitialState(){    return {      name:'alien'    }  },  render(){    const { name  } = this.state    return <div> hello ,world , my name is { name } </div>  }})\n")])])]),v("p",[e._v("这种"),v("code",[e._v("mixins")]),e._v("只能存在"),v("code",[e._v("createClass")]),e._v("中，后来"),v("code",[e._v("React.createClass")]),e._v("连同"),v("code",[e._v("mixins")]),e._v("这种模式被废弃了。"),v("code",[e._v("mixins")]),e._v("会带来一些负面的影响。")]),e._v(" "),v("ul",[v("li",[e._v("1 mixin引入了隐式依赖关系。")]),e._v(" "),v("li",[e._v("2 不同mixins之间可能会有先后顺序甚至代码冲突覆盖的问题")]),e._v(" "),v("li",[e._v("3 mixin代码会导致滚雪球式的复杂性")])]),e._v(" "),v("h4",{attrs:{id:"衍生方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#衍生方式"}},[e._v("#")]),e._v(" 衍生方式")]),e._v(" "),v("p",[v("code",[e._v("createClass")]),e._v("的废弃，不代表"),v("code",[e._v("mixin")]),e._v("模式退出"),v("code",[e._v("react")]),e._v("舞台，在有状态组件"),v("code",[e._v("class")]),e._v("，我们可以通过"),v("strong",[e._v("原型链继承")]),e._v("来实现"),v("code",[e._v("mixins")]),e._v("。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const customMixin = {  /* 自定义 mixins */  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}\nfunction componentClassMixins(Component,mixin){ /* 继承 */  for(let key in mixin){    Component.prototype[key] = mixin[key]  }}\nclass Index extends React.Component{  constructor(){    super()    this.state={  name:'alien' }  }  render(){    return <div> hello,world      <button onClick={ this.say.bind(this) } > to say </button>    </div>  }}componentClassMixins(Index,customMixin)\n")])])]),v("h3",{attrs:{id:"_2extends继承模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2extends继承模式"}},[e._v("#")]),e._v(" ②extends继承模式")]),e._v(" "),v("p",[v("strong",[e._v("原型图")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXy6wIa4Xf7Sdop92zIlibRNia5ufhqNanetpjPSb4Kx5uvaBThWNicwpjw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),v("p",[e._v("在"),v("code",[e._v("class")]),e._v("组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去"),v("code",[e._v("extends")]),e._v("我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Base extends React.Component{  constructor(){    super()    this.state={      name:'alien'    }  }  say(){    console.log('base components')  }  render(){    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>  }}class Index extends Base{  componentDidMount(){    console.log( this.state.name )  }  say(){ /* 会覆盖基类中的 say  */    console.log('extends components')  }}export default Index\n")])])]),v("h3",{attrs:{id:"_3hoc模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3hoc模式"}},[e._v("#")]),e._v(" ③HOC模式")]),e._v(" "),v("p",[v("strong",[e._v("原型图")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXYs6OvOe4Jzm27Vl3bXG29H12prn2V3n5IicRuicMJJvUciagxmiamn5SPg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),v("p",[v("code",[e._v("HOC")]),e._v("是我们本章主要的讲的内容，具体用法，我们接下来会慢慢道来，我们先简单尝试一个"),v("code",[e._v("HOC")]),e._v("。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC(Component) {  return class wrapComponent extends React.Component{     constructor(){       super()       this.state={         name:'alien'       }     }     render=()=><Component { ...this.props } { ...this.state } />  }}\n@HOCclass Index extends React.Component{  say(){    const { name } = this.props    console.log(name)  }  render(){    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>  }}\n")])])]),v("h3",{attrs:{id:"_4自定义hooks模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4自定义hooks模式"}},[e._v("#")]),e._v(" ④自定义hooks模式")]),e._v(" "),v("p",[v("strong",[e._v("原型图")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[v("code",[e._v("hooks")]),e._v("的诞生，一大部分原因是解决"),v("strong",[e._v("无状态组件没有"),v("code",[e._v("state")]),e._v("**和**逻辑难以复用")]),e._v("问题。"),v("code",[e._v("hooks")]),e._v("可以将一段逻辑封装起来，做到开箱即用，我这里就不多讲了，接下来会出"),v("code",[e._v("react-hooks")]),e._v("原理的文章，完成"),v("code",[e._v("react-hooks")]),e._v("三部曲。感兴趣的同学可以看笔者的另外二篇文章，里面详细介绍了"),v("code",[e._v("react-hooks")]),e._v("复用代码逻辑的原则和方案。")]),e._v(" "),v("p",[e._v("传送门：")]),e._v(" "),v("p",[e._v("玩转react-hooks,自定义hooks设计模式及其实战")]),e._v(" "),v("p",[e._v("react-hooks如何使用？")]),e._v(" "),v("h2",{attrs:{id:"_2-高阶组件产生初衷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-高阶组件产生初衷"}},[e._v("#")]),e._v(" 2 高阶组件产生初衷")]),e._v(" "),v("p",[e._v("组件是把"),v("code",[e._v("prop")]),e._v("渲染成"),v("code",[e._v("UI")]),e._v(",而高阶组件是将组件转换成另外一个组件，我们更应该注意的是，经过包装后的组件，获得了那些强化,节省多少逻辑，或是解决了原有组件的那些缺陷，这就是高阶组件的意义。我们先来思考一下高阶组件究竟解决了什么问题🤔🤔🤔？")]),e._v(" "),v("p",[v("strong",[e._v("① 复用逻辑")]),e._v("：高阶组件更像是一个加工"),v("code",[e._v("react")]),e._v("组件的工厂，批量对原有组件进行"),v("strong",[e._v("加工")]),e._v("，"),v("strong",[e._v("包装")]),e._v("处理。我们可以根据业务需求定制化专属的"),v("code",[e._v("HOC")]),e._v(",这样可以解决复用逻辑。")]),e._v(" "),v("p",[v("strong",[e._v("② 强化props")]),e._v("：这个是"),v("code",[e._v("HOC")]),e._v("最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的"),v("code",[e._v("props")]),e._v(",然后混入新的"),v("code",[e._v("props")]),e._v(",来增强组件的功能。代表作"),v("code",[e._v("react-router")]),e._v("中的"),v("code",[e._v("withRouter")]),e._v("。")]),e._v(" "),v("p",[v("strong",[e._v("③ 赋能组件")]),e._v("："),v("code",[e._v("HOC")]),e._v("有一项独特的特性，就是可以给被"),v("code",[e._v("HOC")]),e._v("包裹的业务组件，提供一些拓展功能，比如说"),v("strong",[e._v("额外的生命周期，额外的事件")]),e._v("，但是这种"),v("code",[e._v("HOC")]),e._v("，可能需要和业务组件紧密结合。典型案例"),v("code",[e._v("react-keepalive-router")]),e._v("中的 "),v("code",[e._v("keepaliveLifeCycle")]),e._v("就是通过"),v("code",[e._v("HOC")]),e._v("方式，给业务组件增加了额外的生命周期。")]),e._v(" "),v("p",[v("strong",[e._v("④ 控制渲染")]),e._v("：劫持渲染是"),v("code",[e._v("hoc")]),e._v("一个特性，在"),v("code",[e._v("wrapComponent")]),e._v("包装组件中，可以对原来的组件，进行"),v("code",[e._v("条件渲染")]),e._v("，"),v("code",[e._v("节流渲染")]),e._v("，"),v("code",[e._v("懒加载")]),e._v("等功能，后面会详细讲解，典型代表做"),v("code",[e._v("react-redux")]),e._v("中"),v("code",[e._v("connect")]),e._v("和 "),v("code",[e._v("dva")]),e._v("中 "),v("code",[e._v("dynamic")]),e._v(" 组件懒加载。")]),e._v(" "),v("p",[e._v("我会针对高阶组件的初衷展开，详细介绍其原理已经用法。跟上我的思路，我们先来看一下，高阶组件"),v("strong",[e._v("如何在我们的业务组件中使用的")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"_3-高阶组件使用和编写结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-高阶组件使用和编写结构"}},[e._v("#")]),e._v(" 3 高阶组件使用和编写结构")]),e._v(" "),v("p",[v("code",[e._v("HOC")]),e._v("使用指南是非常简单的，只需要将我们的组件进行包裹就可以了。")]),e._v(" "),v("h3",{attrs:{id:"使用-装饰器模式和函数包裹模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-装饰器模式和函数包裹模式"}},[e._v("#")]),e._v(" 使用：装饰器模式和函数包裹模式")]),e._v(" "),v("p",[e._v("对于"),v("code",[e._v("class")]),e._v("声明的有状态组件，我们可以用装饰器模式，对类组件进行包装：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("@withStyles(styles)@withRouter@keepaliveLifeCycleclass Index extends React.Componen{    /* ... */}\n")])])]),v("p",[v("strong",[e._v("我们要注意一下包装顺序，越靠近"),v("code",[e._v("Index")]),e._v("组件的，就是越内层的"),v("code",[e._v("HOC")]),e._v(",离组件"),v("code",[e._v("Index")]),e._v("也就越近。")])]),e._v(" "),v("p",[e._v("对于无状态组件(函数声明）我们可以这么写：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function Index(){    /* .... */}export default withStyles(styles)(withRouter( keepaliveLifeCycle(Index) )) \n")])])]),v("h3",{attrs:{id:"模型-嵌套hoc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型-嵌套hoc"}},[e._v("#")]),e._v(" 模型：嵌套HOC")]),e._v(" "),v("p",[e._v("对于不需要传递参数的"),v("code",[e._v("HOC")]),e._v("，我们编写模型我们只需要嵌套一层就可以，比如"),v("code",[e._v("withRouter")]),e._v(",")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function withRouter(){    return class wrapComponent extends React.Component{        /* 编写逻辑 */    }}\n")])])]),v("p",[e._v("对于需要参数的"),v("code",[e._v("HOC")]),e._v("，我们需要一层代理，如下：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function connect (mapStateToProps){    /* 接受第一个参数 */    return function connectAdvance(wrapCompoent){        /* 接受组件 */        return class WrapComponent extends React.Component{  }    }}\n")])])]),v("p",[e._v("我们看出两种"),v("code",[e._v("hoc")]),e._v("模型很简单，对于代理函数，可能有一层，可能有很多层，不过不要怕，无论多少层本质上都是一样的，我们只需要一层一层剥离开，分析结构，整个"),v("code",[e._v("hoc")]),e._v("结构和脉络就会清晰可见。吃透"),v("code",[e._v("hoc")]),e._v("也就易如反掌。")]),e._v(" "),v("h2",{attrs:{id:"_4-两种不同的高阶组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-两种不同的高阶组件"}},[e._v("#")]),e._v(" 4 两种不同的高阶组件")]),e._v(" "),v("p",[e._v("常用的高阶组件有两种方式"),v("strong",[e._v("正向的属性代理")]),e._v("和"),v("strong",[e._v("反向的组件继承")]),e._v("，两者之前有一些共性和区别。接下具体介绍两者区别，在第三部分会详细介绍具体实现。")]),e._v(" "),v("h3",{attrs:{id:"正向属性代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#正向属性代理"}},[e._v("#")]),e._v(" 正向属性代理")]),e._v(" "),v("p",[e._v("所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。在"),v("code",[e._v("fiber tree")]),e._v(" 上，先"),v("code",[e._v("mounted")]),e._v("代理组件，然后才是我们的业务组件。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC(WrapComponent){    return class Advance extends React.Component{       state={           name:'alien'       }       render(){           return <WrapComponent  { ...this.props } { ...this.state }  />       }    }}\n")])])]),v("h4",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),v("ul",[v("li",[e._v("① 正常属性代理可以和业务组件低耦合，零耦合，对于"),v("code",[e._v("条件渲染")]),e._v("和"),v("code",[e._v("props属性增强")]),e._v(",只负责控制子组件渲染和传递额外的"),v("code",[e._v("props")]),e._v("就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的"),v("code",[e._v("hoc")]),e._v("，目前开源的"),v("code",[e._v("HOC")]),e._v("基本都是通过这个模式实现的。")]),e._v(" "),v("li",[e._v("② 同样适用于"),v("code",[e._v("class")]),e._v("声明组件，和"),v("code",[e._v("function")]),e._v("声明的组件。")]),e._v(" "),v("li",[e._v("③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免"),v("code",[e._v("反向继承")]),e._v("带来一些副作用，比如生命周期的执行。")]),e._v(" "),v("li",[e._v("④ 可以嵌套使用，多个"),v("code",[e._v("hoc")]),e._v("是可以嵌套使用的，而且一般不会限制包装"),v("code",[e._v("HOC")]),e._v("的先后顺序。")])]),e._v(" "),v("h4",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),v("ul",[v("li",[e._v("① 一般无法直接获取业务组件的状态，如果想要获取，需要"),v("code",[e._v("ref")]),e._v("获取组件实例。")]),e._v(" "),v("li",[e._v("② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。")])]),e._v(" "),v("p",[v("strong",[e._v("例子：")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Index extends React.Component{  render(){    return <div> hello,world  </div>  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends React.Component{     render(){       return <Component { ...this.props } { ...this.state } />     }  }}const newIndex =  HOC(Index) console.log(newIndex.say)\n")])])]),v("p",[v("strong",[e._v("打印结果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h3",{attrs:{id:"反向继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反向继承"}},[e._v("#")]),e._v(" 反向继承")]),e._v(" "),v("p",[e._v("反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须在去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必要要知道当前")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Index extends React.Component{  render(){    return <div> hello,world  </div>  }}function HOC(Component){    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */\n    }}export default HOC(Index)\n")])])]),v("h4",{attrs:{id:"优点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("① 方便获取组件内部状态，比如"),v("code",[e._v("state")]),e._v("，"),v("code",[e._v("props")]),e._v(" ,生命周期,绑定的事件函数等")])]),e._v(" "),v("li",[v("p",[e._v("② "),v("code",[e._v("es6")]),e._v("继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。")])]),e._v(" "),v("li",[v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Index extends React.Component{  render(){    return <div> hello,world  </div>  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends Component{  }}const newIndex =  HOC(Index) console.log(newIndex.say)\n")])])])])]),e._v(" "),v("p",[v("strong",[e._v("打印结果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h4",{attrs:{id:"缺点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),v("ul",[v("li",[e._v("① 无状态组件无法使用。")]),e._v(" "),v("li",[e._v("② 和被包装的组件强耦合，需要知道被包装的组件的内部状态，具体是做什么？")]),e._v(" "),v("li",[e._v("③ 如果多个反向继承"),v("code",[e._v("hoc")]),e._v("嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个"),v("code",[e._v("componentDidMount")]),e._v("，当前"),v("code",[e._v("componentDidMount")]),e._v("会覆盖上一个"),v("code",[e._v("componentDidMount")]),e._v("。这样副作用串联起来，影响很大。")])]),e._v(" "),v("h1",{attrs:{id:"三-如何编写高阶组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-如何编写高阶组件"}},[e._v("#")]),e._v(" 三 如何编写高阶组件")]),e._v(" "),v("p",[e._v("接下来我们来看看，如何编写一个高阶组件，你可以参考如下的情景，去编写属于自己的"),v("code",[e._v("HOC")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"_1-强化props"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-强化props"}},[e._v("#")]),e._v(" 1 强化props")]),e._v(" "),v("h3",{attrs:{id:"_1-混入props"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-混入props"}},[e._v("#")]),e._v(" ① 混入props")]),e._v(" "),v("p",[e._v("这个是高阶组件最常用的功能，承接上层的"),v("code",[e._v("props")]),e._v(",在混入自己的"),v("code",[e._v("props")]),e._v("，来强化组件。")]),e._v(" "),v("p",[v("strong",[e._v("有状态组件(属性代理)")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function classHOC(WrapComponent){    return class  Idex extends React.Component{        state={            name:'alien'        }        componentDidMount(){           console.log('HOC')        }        render(){            return <WrapComponent { ...this.props }  { ...this.state }   />        }    }}function Index(props){  const { name } = props  useEffect(()=>{     console.log( 'index' )  },[])  return <div>    hello,world , my name is { name }  </div>}\nexport default classHOC(Index)\n")])])]),v("p",[v("strong",[e._v("有状态组件(属性代理)")])]),e._v(" "),v("p",[e._v("同样也适用与无状态组件。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function functionHoc(WrapComponent){    return function Index(props){        const [ state , setState ] = useState({ name :'alien'  })               return  <WrapComponent { ...props }  { ...state }   />    }}\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h3",{attrs:{id:"_2-抽离state控制更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-抽离state控制更新"}},[e._v("#")]),e._v(" ② 抽离state控制更新")]),e._v(" "),v("p",[e._v("高阶组件可以将"),v("code",[e._v("HOC")]),e._v("的"),v("code",[e._v("state")]),e._v("的配合起来，控制业务组件的更新。这种用法在"),v("code",[e._v("react-redux")]),e._v("中"),v("code",[e._v("connect")]),e._v("高阶组件中用到过，用于处理来自"),v("code",[e._v("redux")]),e._v("中"),v("code",[e._v("state")]),e._v("更改，带来的订阅更新作用。")]),e._v(" "),v("p",[e._v("我们将上述代码进行改造。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function classHOC(WrapComponent){  return class  Idex extends React.Component{      constructor(){        super()        this.state={          name:'alien'        }      }      changeName(name){        this.setState({ name })      }      render(){          return <WrapComponent { ...this.props }  { ...this.state } changeName={this.changeName.bind(this)  }  />      }  }}function Index(props){  const [ value ,setValue ] = useState(null)  const { name ,changeName } = props  return <div>    <div>   hello,world , my name is { name }</div>    改变name <input onChange={ (e)=> setValue(e.target.value)  }  />    <button onClick={ ()=>  changeName(value) }  >确定</button>  </div>}\nexport default classHOC(Index)\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h2",{attrs:{id:"_2-控制渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-控制渲染"}},[e._v("#")]),e._v(" 2 控制渲染")]),e._v(" "),v("p",[e._v("控制渲染是高阶组件的一个很重要的特性，上边说到的两种高阶组件，都能完成对组件渲染的控制。具体实现还是有区别的，我们一起来探索一下。")]),e._v(" "),v("h3",{attrs:{id:"_2-1-条件渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-条件渲染"}},[e._v("#")]),e._v(" 2.1 条件渲染")]),e._v(" "),v("h4",{attrs:{id:"_1-基础-动态渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-动态渲染"}},[e._v("#")]),e._v(" ① 基础 ：动态渲染")]),e._v(" "),v("p",[e._v("对于属性代理的高阶组件，虽然不能在内部操控渲染状态，但是可以在外层控制当前组件是否渲染，这种情况应用于，"),v("strong",[e._v("权限隔离")]),e._v("，"),v("strong",[e._v("懒加载")]),e._v(" ，"),v("strong",[e._v("延时加载")]),e._v("等场景。")]),e._v(" "),v("p",[v("strong",[e._v("实现一个动态挂载组件的HOC")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('function renderHOC(WrapComponent){  return class Index  extends React.Component{      constructor(props){        super(props)        this.state={ visible:true }        }      setVisible(){         this.setState({ visible:!this.state.visible })      }      render(){         const {  visible } = this.state          return <div className="box"  >           <button onClick={ this.setVisible.bind(this) } > 挂载组件 </button>           { visible ? <WrapComponent { ...this.props } setVisible={ this.setVisible.bind(this) }   />  : <div className="icon" ><SyncOutlined spin  className="theicon"  /></div> }         </div>      }  }}\nclass Index extends React.Component{  render(){    const { setVisible } = this.props    return <div className="box" >        <p>hello,my name is alien</p>        <img  src=\'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&fm=26&gp=0.jpg\'   />         <button onClick={() => setVisible()}  > 卸载当前组件 </button>    </div>  }}export default renderHOC(Index)\n')])])]),v("p",[e._v("效果：")]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h4",{attrs:{id:"_2-进阶-分片渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-进阶-分片渲染"}},[e._v("#")]),e._v(" ② 进阶 ：分片渲染")]),e._v(" "),v("p",[e._v("是不是感觉不是很过瘾，为了让大家加强对"),v("code",[e._v("HOC")]),e._v("条件渲染的理解，我再做一个"),v("strong",[e._v("分片渲染+懒加载")]),e._v("功能。为了让大家明白，我也是绞尽脑汁啊😂😂😂。")]),e._v(" "),v("p",[v("strong",[e._v("进阶：实现一个懒加载功能的HOC，可以实现组件的分片渲染,用于分片渲染页面，不至于一次渲染大量组件造成白屏效果")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('const renderQueue = []let isFirstrender = false\nconst tryRender = ()=>{  const render = renderQueue.shift()  if(!render) return  setTimeout(()=>{    render() /* 执行下一段渲染 */  },300)} /* HOC */function renderHOC(WrapComponent){    return function Index(props){      const [ isRender , setRender ] = useState(false)      useEffect(()=>{        renderQueue.push(()=>{  /* 放入待渲染队列中 */          setRender(true)        })        if(!isFirstrender) {          tryRender() /**/          isFirstrender = true        }      },[])      return isRender ? <WrapComponent tryRender={tryRender}  { ...props }  /> : <div className=\'box\' ><div className="icon" ><SyncOutlined   spin /></div></div>    }}/* 业务组件 */class Index extends React.Component{  componentDidMount(){    const { name , tryRender} = this.props    /* 上一部分渲染完毕，进行下一部分渲染 */    tryRender()    console.log( name+\'渲染\')  }  render(){    return <div>        <img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;fm=26&amp;gp=0.jpg" />    </div>  }}/* 高阶组件包裹 */const Item = renderHOC(Index)\nexport default () => {  return <React.Fragment>      <Item name="组件一" />      <Item name="组件二" />      <Item name="组件三" />  </React.Fragment>}\n')])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[e._v("大致流程，初始化的时候，"),v("code",[e._v("HOC")]),e._v("中将渲染真正组件的渲染函数，放入"),v("code",[e._v("renderQueue")]),e._v("队列中，然后初始化渲染一次，接下来，每一个项目组件，完成 "),v("code",[e._v("didMounted")]),e._v(" 状态后，会从队列中取出下一个渲染函数，渲染下一个组件, 一直到所有的渲染任务全部执行完毕，渲染队列清空，有效的进行分片的渲染，这种方式对海量数据展示，很奏效。")]),e._v(" "),v("p",[e._v("用"),v("code",[e._v("HOC")]),e._v("实现了条件渲染-分片渲染的功能，实际条件渲染理解起来很容易，就是通过变量，控制是否挂载组件，从而满足项目本身需求，条件渲染可以演变成很多模式，我这里介绍了条件渲染的二种方式，希望大家能够理解精髓所在。")]),e._v(" "),v("h4",{attrs:{id:"_3-进阶-异步组件-懒加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-进阶-异步组件-懒加载"}},[e._v("#")]),e._v(" ③ 进阶：异步组件(懒加载)")]),e._v(" "),v("p",[e._v("不知道大家有没有用过"),v("code",[e._v("dva")]),e._v(",里面的"),v("code",[e._v("dynamic")]),e._v("就是应用"),v("code",[e._v("HOC")]),e._v("模式实现的组件异步加载，我这里简化了一下，提炼核心代码，如下：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* 路由懒加载HOC */export default function AsyncRouter(loadRouter) {  return class Content extends React.Component {    state = {Component: null}    componentDidMount() {      if (this.state.Component) return      loadRouter()        .then(module => module.default)        .then(Component => this.setState({Component},         ))    }    render() {      const {Component} = this.state      return Component ? <Component {      ...this.props      }      /> : null    }  }}\n")])])]),v("p",[e._v("使用")]),e._v(" "),v("ul",[v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const Index = AsyncRouter(()=>import('../pages/index'))\n")])])]),v("p",[v("code",[e._v("hoc")]),e._v("还可以配合其他"),v("code",[e._v("API")]),e._v("，做一下衍生的功能。如上配合"),v("code",[e._v("import")]),e._v("实现异步加载功能。"),v("code",[e._v("HOC")]),e._v("用起来非常灵活，")]),e._v(" "),v("h4",{attrs:{id:"_4-反向继承-渲染劫持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-反向继承-渲染劫持"}},[e._v("#")]),e._v(" ④ 反向继承 ：渲染劫持")]),e._v(" "),v("p",[v("strong",[e._v("HOC反向继承模式，可以实现颗粒化的渲染劫持，也就是可以控制基类组件的"),v("code",[e._v("render")]),e._v("函数，还可以篡改props，或者是"),v("code",[e._v("children")]),e._v("，我们接下来看看，这种状态下，怎么使用高阶组件。")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const HOC = (WrapComponent) =>  class Index  extends WrapComponent {    render() {      if (this.props.visible) {        return super.render()      } else {        return <div>暂无数据</div>      }    }  }\n")])])]),v("h4",{attrs:{id:"_5-反向继承-修改渲染树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-反向继承-修改渲染树"}},[e._v("#")]),e._v(" ⑤ 反向继承：修改渲染树")]),e._v(" "),v("p",[v("strong",[e._v("修改渲染状态(劫持render替换子节点)")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Index extends React.Component{  render(){    return <div>       <ul>         <li>react</li>         <li>vue</li>         <li>Angular</li>       </ul>    </div>  }}\nfunction HOC (Component){  return class Advance extends Component {    render() {      const element = super.render()      const otherProps = {        name:'alien'      }      /* 替换 Angular 元素节点 */      const appendElement = React.createElement('li' ,{} , `hello ,world , my name  is ${ otherProps.name }` )      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=>{           if(index === 2) return appendElement           return  child      })       return  React.cloneElement(element, element.props, newchild)    }  }}export  default HOC(Index)\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[e._v("我们用劫持渲染的方式，来操纵"),v("code",[e._v("super.render()")]),e._v("后的"),v("code",[e._v("React.element")]),e._v("元素，然后配合 "),v("code",[e._v("createElement")]),e._v(" , "),v("code",[e._v("cloneElement")]),e._v(" , "),v("code",[e._v("React.Children")]),e._v(" 等 "),v("code",[e._v("api")]),e._v(",可以灵活操纵，真正的渲染"),v("code",[e._v("react.element")]),e._v("，可以说是偷天换日，不亦乐乎。")]),e._v(" "),v("h3",{attrs:{id:"_2-2节流渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2节流渲染"}},[e._v("#")]),e._v(" 2.2节流渲染")]),e._v(" "),v("p",[v("code",[e._v("hoc")]),e._v("除了可以进行"),v("strong",[e._v("条件渲染")]),e._v("，"),v("strong",[e._v("渲染劫持")]),e._v("功能外，还可以进行节流渲染，也就是可以优化性能，具体怎么做，请跟上我的节奏往下看。")]),e._v(" "),v("h4",{attrs:{id:"_1-基础-节流原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-节流原理"}},[e._v("#")]),e._v(" ① 基础: 节流原理")]),e._v(" "),v("p",[v("code",[e._v("hoc")]),e._v("可以配合"),v("code",[e._v("hooks")]),e._v("的"),v("code",[e._v("useMemo")]),e._v("等"),v("code",[e._v("API")]),e._v("配合使用，可以实现对业务组件的渲染控制，减少渲染次数，从而达到优化性能的效果。如下案例，我们期望当且仅当"),v("code",[e._v("num")]),e._v("改变的时候，渲染组件，但是不影响接收的"),v("code",[e._v("props")]),e._v("。我们应该这样写我们的"),v("code",[e._v("HOC")]),e._v("。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC (Component){     return function renderWrapComponent(props){       const { num } = props       const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ num ])       return RenderElement     }}class Index extends React.Component{  render(){     console.log(`当前组件是否渲染`,this.props)     return <div>hello,world, my name is alien </div>  }}const IndexHoc = HOC(Index)\nexport default ()=> {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return <div>        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />        <button onClick={() => setNumber(num + 1) } >num++</button>        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>    </div>}\n")])])]),v("p",[v("strong",[e._v("效果：")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[e._v("如图所示,当我们只有点击 "),v("code",[e._v("num++")]),e._v("时候，才重新渲染子组件，点击其他按钮，只是负责传递了"),v("code",[e._v("props")]),e._v(",达到了期望的效果。")]),e._v(" "),v("h4",{attrs:{id:"_2-进阶-定制化渲染流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-进阶-定制化渲染流"}},[e._v("#")]),e._v(" ② 进阶：定制化渲染流")]),e._v(" "),v("p",[e._v("思考：🤔上述的案例只是介绍了原理，在实际项目中，是量化生产不了的，原因是，我们需要针对不同"),v("code",[e._v("props")]),e._v("变化，写不同的"),v("code",[e._v("HOC")]),e._v("组件，这样根本起不了"),v("code",[e._v("Hoc")]),e._v("真正的用途，也就是"),v("code",[e._v("HOC")]),e._v("产生的初衷。所以我们需要对上述"),v("code",[e._v("hoc")]),e._v("进行改造升级，是组件可以根据定制化方向，去渲染组件。也就是"),v("code",[e._v("Hoc")]),e._v("生成的时候，已经按照某种契约去执行渲染。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC (rule){     return function (Component){        return function renderWrapComponent(props){          const dep = rule(props)          const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ dep ])          return RenderElement        }     }}/* 只有 props 中 num 变化 ，渲染组件  */@HOC( (props)=> props['num'])class IndexHoc extends React.Component{  render(){     console.log(`组件一渲染`,this.props)     return <div> 组件一 ：hello,world </div>  }}\n/* 只有 props 中 num1 变化 ，渲染组件  */@HOC((props)=> props['num1'])class IndexHoc1 extends React.Component{  render(){     console.log(`组件二渲染`,this.props)     return <div> 组件二 ：my name is alien </div>  }}export default ()=> {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return <div>        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />        <IndexHoc1  num={ num } num1={num1} num2={ num2 }  />        <button onClick={() => setNumber(num + 1) } >num++</button>        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>    </div>}\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[e._v("完美实现了效果。这用高阶组件模式，可以灵活控制"),v("code",[e._v("React")]),e._v("组件层面上的，"),v("strong",[v("code",[e._v("props")]),e._v("数据流")]),e._v("和"),v("strong",[e._v("更新流")]),e._v("，优秀的高阶组件有 "),v("code",[e._v("mobx")]),e._v(" 中"),v("code",[e._v("observer")]),e._v(" ,"),v("code",[e._v("inject")]),e._v(" , "),v("code",[e._v("react-redux")]),e._v("中的"),v("code",[e._v("connect")]),e._v(",感兴趣的同学，可以抽时间研究一下。")]),e._v(" "),v("h2",{attrs:{id:"_3-赋能组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-赋能组件"}},[e._v("#")]),e._v(" 3 赋能组件")]),e._v(" "),v("p",[e._v("高阶组件除了上述两种功能之外，还可以赋能组件，比如加一些"),v("strong",[e._v("额外"),v("code",[e._v("生命周期")])]),e._v("，"),v("strong",[e._v("劫持事件")]),e._v("，"),v("strong",[e._v("监控日志")]),e._v("等等。")]),e._v(" "),v("h3",{attrs:{id:"_3-1-劫持原型链-劫持生命周期-事件函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-劫持原型链-劫持生命周期-事件函数"}},[e._v("#")]),e._v(" 3.1 劫持原型链-劫持生命周期，事件函数")]),e._v(" "),v("h4",{attrs:{id:"_1-属性代理实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-属性代理实现"}},[e._v("#")]),e._v(" ① 属性代理实现")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return class wrapComponent extends React.Component{      render(){        return <Component {...this.props}  />      }  }}@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return <div>hello,world</div>   }}\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h4",{attrs:{id:"_2-反向继承实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-反向继承实现"}},[e._v("#")]),e._v(" ② 反向继承实现")]),e._v(" "),v("p",[e._v("反向继承，因为在继承原有组件的基础上，可以对原有组件的"),v("strong",[e._v("生命周期")]),e._v("或"),v("strong",[e._v("事件")]),e._v("进行劫持，甚至是替换。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC (Component){  const didMount = Component.prototype.componentDidMount  return class wrapComponent extends Component{      componentDidMount(){        console.log('------劫持生命周期------')        if (didMount) {           didMount.apply(this) /* 注意 `this` 指向问题。*/        }      }      render(){        return super.render()      }  }}\n@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return <div>hello,world</div>   }}\n")])])]),v("h3",{attrs:{id:"_3-2-事件监控"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-事件监控"}},[e._v("#")]),e._v(" 3.2 事件监控")]),e._v(" "),v("p",[v("code",[e._v("HOC")]),e._v("还可以对原有组件进行监控。比如对一些"),v("code",[e._v("事件监控")]),e._v("，"),v("code",[e._v("错误监控")]),e._v("，"),v("code",[e._v("事件监听")]),e._v("等一系列操作。")]),e._v(" "),v("h4",{attrs:{id:"_1-组件内的事件监听"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-组件内的事件监听"}},[e._v("#")]),e._v(" ① 组件内的事件监听")]),e._v(" "),v("p",[e._v("接下来，我们做一个"),v("code",[e._v("HOC")]),e._v(",只对组件内的点击事件做一个监听效果。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function ClickHoc (Component){  return  function Wrap(props){    const dom = useRef(null)    useEffect(()=>{     const handerClick = () => console.log('发生点击事件')      dom.current.addEventListener('click',handerClick)     return () => dom.current.removeEventListener('click',handerClick)    },[])    return  <div ref={dom}  ><Component  {...props} /></div>  }}\n@ClickHocclass Index extends React.Component{   render(){     return <div  className='index'  >       <p>hello，world</p>       <button>组件内部点击</button>    </div>   }}export default ()=>{  return <div className='box'  >     <Index />     <button>组件外部点击</button>  </div>}\n")])])]),v("p",[v("strong",[e._v("效果")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("h3",{attrs:{id:"_3-ref助力操控组件实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-ref助力操控组件实例"}},[e._v("#")]),e._v(" 3 ref助力操控组件实例")]),e._v(" "),v("p",[e._v("对于属性代理我们虽然不能直接获取组件内的状态，但是我们可以通过"),v("code",[e._v("ref")]),e._v("获取组件实例,获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是："),v("code",[e._v("class")]),e._v("声明的有状态组件才有实例，"),v("code",[e._v("function")]),e._v("声明的无状态组件不存在实例。")]),e._v(" "),v("h4",{attrs:{id:"_1-属性代理-添加额外生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-属性代理-添加额外生命周期"}},[e._v("#")]),e._v(" ① 属性代理-添加额外生命周期")]),e._v(" "),v("p",[e._v("我们可以针对某一种情况, 给组件增加额外的生命周期，我做了一个简单的"),v("code",[e._v("demo")]),e._v("，监听"),v("code",[e._v("number")]),e._v("改变，如果"),v("code",[e._v("number")]),e._v("改变，就自动触发组件的监听函数"),v("code",[e._v("handerNumberChange")]),e._v("。具体写法如下")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function Hoc(Component){  return class WrapComponent extends React.Component{      constructor(){        super()        this.node = null      }      UNSAFE_componentWillReceiveProps(nextprops){          if(nextprops.number !== this.props.number ){            this.node.handerNumberChange  &&  this.node.handerNumberChange.call(this.node)          }      }      render(){        return <Component {...this.props} ref={(node) => this.node = node }  />      }  }}@Hocclass Index extends React.Component{  handerNumberChange(){      /* 监听 number 改变 */  }  render(){    return <div>hello,world</div>  }}\n")])])]),v("p",[e._v("这种写法有点不尽人意，大家不要着急，在第四部分，源码实战中，我会介绍一种更好的场景。方便大家理解"),v("code",[e._v("Hoc")]),e._v("对原有组件的赋能。")]),e._v(" "),v("h2",{attrs:{id:"_4-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-总结"}},[e._v("#")]),e._v(" 4 总结")]),e._v(" "),v("p",[e._v("上面我分别按照"),v("code",[e._v("hoc")]),e._v("主要功能，"),v("strong",[e._v("强化props")]),e._v(" ， "),v("strong",[e._v("控制渲染")]),e._v(" ，"),v("strong",[e._v("赋能组件")]),e._v(" 三个方向对"),v("code",[e._v("HOC")]),e._v("编写做了一个详细介绍，和应用场景的介绍，目的"),v("strong",[e._v("让大家在理解高阶组件的时候，更明白什么时候会用到？,怎么样去写？`")]),e._v(" 里面涵盖的知识点我总一个总结。")]),e._v(" "),v("p",[e._v("对于属性代理HOC，我们可以：")]),e._v(" "),v("ul",[v("li",[e._v("强化props & 抽离state。")]),e._v(" "),v("li",[e._v("条件渲染，控制渲染，分片渲染，懒加载。")]),e._v(" "),v("li",[e._v("劫持事件和生命周期")]),e._v(" "),v("li",[e._v("ref控制组件实例")]),e._v(" "),v("li",[e._v("添加事件监听器，日志")])]),e._v(" "),v("p",[e._v("对于反向代理的HOC,我们可以：")]),e._v(" "),v("ul",[v("li",[e._v("劫持渲染，操纵渲染树")]),e._v(" "),v("li",[e._v("控制/替换生命周期，直接获取组件状态，绑定事件。")])]),e._v(" "),v("p",[e._v("每个应用场景，我都举了例子🌰🌰，大家可以结合例子深入了解一下其原理和用途。")]),e._v(" "),v("h1",{attrs:{id:"四-高阶组件源码级实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四-高阶组件源码级实践"}},[e._v("#")]),e._v(" 四 高阶组件源码级实践")]),e._v(" "),v("p",[v("code",[e._v("hoc")]),e._v("的应用场景有很多，也有很多好的开源项目，供我们学习和参考，接下来我真对三个方向上的功能用途，分别从源码角度解析"),v("code",[e._v("HOC")]),e._v("的用途。")]),e._v(" "),v("h2",{attrs:{id:"_1-强化prop-withroute"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-强化prop-withroute"}},[e._v("#")]),e._v(" 1 强化prop- withRoute")]),e._v(" "),v("p",[e._v("用过"),v("code",[e._v("withRoute")]),e._v("的同学，都明白其用途，"),v("code",[e._v("withRoute")]),e._v("用途就是，对于没有被"),v("code",[e._v("Route")]),e._v("包裹的组件，给添加"),v("code",[e._v("history")]),e._v("对象等和路由相关的状态，方便我们在任意组件中，都能够获取路由状态，进行路由跳转，这个"),v("code",[e._v("HOC")]),e._v("目的很清楚，就是强化"),v("code",[e._v("props")]),e._v(",把"),v("code",[e._v("Router")]),e._v("相关的状态都混入到"),v("code",[e._v("props")]),e._v("中，我们看看具体怎么实现的。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function withRouter(Component) {  const displayName = `withRouter(${Component.displayName || Component.name})`;  const C = props => {      /*  获取 */    const { wrappedComponentRef, ...remainingProps } = props;    return (      <RouterContext.Consumer>        {context => {          return (            <Component              {...remainingProps}              {...context}              ref={wrappedComponentRef}            />          );        }}      </RouterContext.Consumer>    );  };\n  C.displayName = displayName;  C.WrappedComponent = Component;  /* 继承静态属性 */  return hoistStatics(C, Component);}\nexport default withRouter\n")])])]),v("p",[v("code",[e._v("withRoute")]),e._v("的流程实际很简单，就是先从"),v("code",[e._v("props")]),e._v("分离出"),v("code",[e._v("ref")]),e._v("和"),v("code",[e._v("props")]),e._v(",然后从存放整个"),v("code",[e._v("route")]),e._v("对象上下文"),v("code",[e._v("RouterContext")]),e._v("取出"),v("code",[e._v("route")]),e._v("对象,然后混入到原始组件的"),v("code",[e._v("props")]),e._v("中，最后用"),v("code",[e._v("hoistStatics")]),e._v("继承静态属性。至于"),v("code",[e._v("hoistStatics")]),e._v("我们稍后会讲到。")]),e._v(" "),v("h2",{attrs:{id:"_2-控制渲染案例-connect"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-控制渲染案例-connect"}},[e._v("#")]),e._v(" 2 控制渲染案例 connect")]),e._v(" "),v("p",[e._v("由于"),v("code",[e._v("connect")]),e._v("源码比较长和难以理解，所以我们提取精髓，精简精简再精简, 总结的核心功能如下,"),v("code",[e._v("connect")]),e._v("的作用也有"),v("code",[e._v("合并props")]),e._v("，但是更重要的是接受"),v("code",[e._v("state")]),e._v("，来控制更新组件。下面这个代码中，为了方便大家理解，我都给简化了。希望大家能够理解"),v("code",[e._v("hoc")]),e._v("如何"),v("strong",[e._v("派发")]),e._v("和"),v("strong",[e._v("控制")]),e._v("更新流的。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("import store from './redux/store'import { ReactReduxContext } from './Context'import { useContext } from 'react'function connect(mapStateToProps){   /* 第一层：接收订阅state函数 */    return function wrapWithConnect (WrappedComponent){        /* 第二层：接收原始组件 */        function ConnectFunction(props){            const [ , forceUpdate ] = useState(0)            const { reactReduxForwardedRef ,...wrapperProps } = props                        /* 取出Context */            const { store } = useContext(ReactReduxContext)\n            /* 强化props：合并 store state 和 props  */            const trueComponentProps = useMemo(()=>{                  /* 只有props或者订阅的state变化，才返回合并后的props */                 return selectorFactory(mapStateToProps(store.getState()),wrapperProps)             },[ store , wrapperProps ])\n            /* 只有 trueComponentProps 改变时候,更新组件。*/            const renderedWrappedComponent = useMemo(              () => (                <WrappedComponent                  {...trueComponentProps}                  ref={reactReduxForwardedRef}                />              ),              [reactReduxForwardedRef, WrappedComponent, trueComponentProps]            )            useEffect(()=>{              /* 订阅更新 */               const checkUpdate = () => forceUpdate(new Date().getTime())               store.subscribe( checkUpdate )            },[ store ])            return renderedWrappedComponent        }        /* React.memo 包裹  */        const Connect = React.memo(ConnectFunction)\n        /* 处理hoc,获取ref问题 */          if(forwardRef){          const forwarded = React.forwardRef(function forwardConnectRef( props,ref) {            return <Connect {...props} reactReduxForwardedRef={ref} reactReduxForwardedRef={ref} />          })          return hoistStatics(forwarded, WrappedComponent)        }         /* 继承静态属性 */        return hoistStatics(Connect,WrappedComponent)    } }export default Index\n")])])]),v("p",[v("code",[e._v("connect")]),e._v(" 涉及到的功能点还真不少呢，首先第一层接受订阅函数，第二层接收原始组件，然后用"),v("code",[e._v("forwardRef")]),e._v("处理"),v("code",[e._v("ref")]),e._v(",用"),v("code",[e._v("hoistStatics")]),e._v(" 处理静态属性的继承，在包装组件内部，合并"),v("code",[e._v("props")]),e._v(","),v("code",[e._v("useMemo")]),e._v("缓存原始组件，只有合并后的"),v("code",[e._v("props")]),e._v("发生变化，才更新组件，然后在"),v("code",[e._v("useEffect")]),e._v("内部通过"),v("code",[e._v("store.subscribe()")]),e._v("订阅更新。这里省略了"),v("code",[e._v("Subscription")]),e._v("概念，真正的"),v("code",[e._v("connect")]),e._v("中有一个"),v("code",[e._v("Subscription")]),e._v("专门负责订阅消息。")]),e._v(" "),v("h2",{attrs:{id:"_3-赋能组件-缓存生命周期-keepalivelifecycle"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-赋能组件-缓存生命周期-keepalivelifecycle"}},[e._v("#")]),e._v(" 3 赋能组件-缓存生命周期 keepaliveLifeCycle")]),e._v(" "),v("p",[e._v("之前笔者写了一个"),v("code",[e._v("react")]),e._v("缓存页面的开源库"),v("code",[e._v("react-keepalive-router")]),e._v("，可以实现"),v("code",[e._v("vue")]),e._v("中 "),v("code",[e._v("keepalive")]),e._v(" + "),v("code",[e._v("router")]),e._v("功能，最初的版本没有缓存周期的，但是后来热心读者，期望在被缓存的路由组件中加入缓存周期，类似"),v("code",[e._v("activated")]),e._v("这种的，后来经过我的分析打算用"),v("code",[e._v("HOC")]),e._v("来实现此功能。")]),e._v(" "),v("p",[e._v("于是乎"),v("code",[e._v("react-keepalive-router")]),e._v("加入了全新的页面组件生命周期 "),v("code",[e._v("actived")]),e._v(" 和 "),v("code",[e._v("unActived")]),e._v(", "),v("code",[e._v("actived")]),e._v(" 作为缓存路由组件激活时候用，初始化的时候会默认执行一次 , "),v("code",[e._v("unActived")]),e._v(" 作为路由组件缓存完成后调用。但是生命周期需要用一个 "),v("code",[e._v("HOC")]),e._v(" 组件"),v("code",[e._v("keepaliveLifeCycle")]),e._v(" 包裹。")]),e._v(" "),v("p",[e._v("使用")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("import React   from 'react'import { keepaliveLifeCycle } from 'react-keepalive-router'\n@keepaliveLifeCycleclass index extends React.Component<any,any>{\n    state={        activedNumber:0,        unActivedNumber:0    }    actived(){        this.setState({            activedNumber:this.state.activedNumber + 1        })    }    unActived(){        this.setState({            unActivedNumber:this.state.unActivedNumber + 1        })    }    render(){        const { activedNumber , unActivedNumber } = this.state        return <div  style={{ marginTop :'50px' }}  >           <div> 页面 actived 次数：{activedNumber} </div>           <div> 页面 unActived 次数：{unActivedNumber} </div>        </div>    }}export default index\n")])])]),v("p",[e._v("**\n**")]),e._v(" "),v("p",[v("strong",[e._v("原理")])]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("import {lifeCycles} from '../core/keeper'import hoistNonReactStatic from 'hoist-non-react-statics'function keepaliveLifeCycle(Component) {   class Hoc extends React.Component {    cur = null    handerLifeCycle = type => {      if (!this.cur) return      const lifeCycleFunc = this.cur[type]      isFuntion(lifeCycleFunc) && lifeCycleFunc.call(this.cur)    }    componentDidMount() {       const {cacheId} = this.props      cacheId && (lifeCycles[cacheId] = this.handerLifeCycle)    }    componentWillUnmount() {      const {cacheId} = this.props      delete lifeCycles[cacheId]    }     render=() => <Component {...this.props} ref={cur => (this.cur = cur)}/>  }  return hoistNonReactStatic(Hoc,Component)}\n")])])]),v("p",[v("code",[e._v("keepaliveLifeCycle")]),e._v(" 的原理很简单，就是通过"),v("code",[e._v("ref")]),e._v("或获取 "),v("code",[e._v("class")]),e._v(" 组件的实例,在 "),v("code",[e._v("hoc")]),e._v(" 初始化时候"),v("strong",[e._v("进行生命周期的绑定")]),e._v(", 在 "),v("code",[e._v("hoc")]),e._v(" 销毁阶段，对生命周期进行解绑, 然后交给"),v("code",[e._v("keeper")]),e._v("统一调度，"),v("code",[e._v("keeper")]),e._v("通过调用实例下面的生命周期函数，来实现缓存生命周期功能的。")]),e._v(" "),v("h1",{attrs:{id:"五-高阶组件的注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五-高阶组件的注意事项"}},[e._v("#")]),e._v(" 五 高阶组件的注意事项")]),e._v(" "),v("h2",{attrs:{id:"_1-谨慎修改原型链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-谨慎修改原型链"}},[e._v("#")]),e._v(" 1 谨慎修改原型链")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return  Component}\n")])])]),v("p",[e._v("这样做会产生一些不良后果。比如如果你再用另一个同样会修改 "),v("code",[e._v("componentDidMount")]),e._v(" 的 "),v("code",[e._v("HOC")]),e._v(" 增强它，那么前面的 "),v("code",[e._v("HOC")]),e._v(" 就会失效！同时，这个 "),v("code",[e._v("HOC")]),e._v(" 也无法应用于没有生命周期的函数组件。")]),e._v(" "),v("h2",{attrs:{id:"_2-继承静态属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承静态属性"}},[e._v("#")]),e._v(" 2 继承静态属性")]),e._v(" "),v("p",[e._v("在用属性代理的方式编写"),v("code",[e._v("HOC")]),e._v("的时候，要注意的是就是，静态属性丢失的问题，前面提到了，如果不做处理，静态方法就会全部丢失。")]),e._v(" "),v("h3",{attrs:{id:"手动继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#手动继承"}},[e._v("#")]),e._v(" 手动继承")]),e._v(" "),v("p",[e._v("我们可以手动将原始组件的静态方法"),v("code",[e._v("copy")]),e._v("到 "),v("code",[e._v("hoc")]),e._v("组件上来，但前提是必须准确知道应该拷贝哪些方法。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  // 必须准确知道应该拷贝哪些方法   WrappedComponent.staticMethod = Component.staticMethod  return WrappedComponent}\n")])])]),v("h3",{attrs:{id:"引入第三方库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引入第三方库"}},[e._v("#")]),e._v(" 引入第三方库")]),e._v(" "),v("p",[e._v("这样每个静态方法都绑定会很累，尤其对于开源的"),v("code",[e._v("hoc")]),e._v("，"),v("strong",[e._v("对原生组件的静态方法是未知的")]),e._v(",我们可以使用 "),v("code",[e._v("hoist-non-react-statics")]),e._v(" 自动拷贝所有的静态方法:")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("import hoistNonReactStatic from 'hoist-non-react-statics'function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  hoistNonReactStatic(WrappedComponent,Component)  return WrappedComponent}\n")])])]),v("h2",{attrs:{id:"_3-跨层级捕获ref"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-跨层级捕获ref"}},[e._v("#")]),e._v(" 3 跨层级捕获ref")]),e._v(" "),v("p",[e._v("高阶组件的约定是将所有 "),v("code",[e._v("props")]),e._v(" 传递给被包装组件，但这对于 "),v("code",[e._v("refs")]),e._v(" 并不适用。那是因为 "),v("code",[e._v("ref")]),e._v(" 实际上并不是一个 "),v("code",[e._v("prop")]),e._v(" - 就像 "),v("code",[e._v("key")]),e._v(" 一样，它是由 "),v("code",[e._v("React")]),e._v(" 专门处理的。如果将 "),v("code",[e._v("ref")]),e._v(" 添加到 "),v("code",[e._v("HOC")]),e._v(" 的返回组件中，则 "),v("code",[e._v("ref")]),e._v(" 引用指向容器组件，而不是被包装组件。我们可以通过"),v("code",[e._v("forwardRef")]),e._v("来解决这个问题。")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/** *  * @param {*} Component 原始组件 * @param {*} isRef  是否开启ref模式 */function HOC(Component,isRef){  class Wrap extends React.Component{     render(){        const { forwardedRef ,...otherprops  } = this.props        return <Component ref={forwardedRef}  {...otherprops}  />     }  }    if(isRef){      return  React.forwardRef((props,ref)=> <Wrap forwardedRef={ref} {...props} /> )    }    return Wrap}\nclass Index extends React.Component{  componentDidMount(){      console.log(666)  }  render(){    return <div>hello,world</div>  }}\nconst HocIndex =  HOC(Index,true)\nexport default ()=>{  const node = useRef(null)  useEffect(()=>{     /* 就可以跨层级，捕获到 Index 组件的实例了 */     console.log(node.current.componentDidMount)  },[])  return <div><HocIndex ref={node}  /></div>}\n")])])]),v("p",[v("strong",[e._v("打印结果：")])]),e._v(" "),v("p",[v("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),v("p",[e._v("如上就解决了,"),v("code",[e._v("HOC")]),e._v("跨层级捕获"),v("code",[e._v("ref")]),e._v("的问题。")]),e._v(" "),v("h2",{attrs:{id:"_4-render中不要声明hoc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-render中不要声明hoc"}},[e._v("#")]),e._v(" 4 render中不要声明HOC")]),e._v(" "),v("p",[e._v("🙅错误写法：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class Index extends React.Component{  render(){     const WrapHome = HOC(Home)     return <WrapHome />  }}\n")])])]),v("p",[e._v("如果这么写，会造成一个极大的问题，因为每一次"),v("code",[e._v("HOC")]),e._v("都会返回一个新的"),v("code",[e._v("WrapHome")]),e._v(","),v("code",[e._v("react diff")]),e._v("会判定两次"),v("strong",[e._v("不是同一个组件")]),e._v("，那么每次"),v("code",[e._v("Index")]),e._v(" 组件 "),v("code",[e._v("render")]),e._v("触发，"),v("code",[e._v("WrapHome")]),e._v("，会重新挂载，状态会"),v("strong",[e._v("全都丢失")]),e._v("。如果想要动态绑定"),v("code",[e._v("HOC")]),e._v(",请参考如下方式。")]),e._v(" "),v("p",[e._v("🙆正确写法：")]),e._v(" "),v("ul",[v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li"),e._v(" "),v("li")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const WrapHome = HOC(Home)class index extends React.Component{  render(){     return <WrapHome />  }}\n")])])]),v("h1",{attrs:{id:"六-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六-总结"}},[e._v("#")]),e._v(" 六 总结")]),e._v(" "),v("p",[e._v("本文从高阶组件功能为切入点，介绍二种不同的高阶组件如何编写，应用场景，以及实践。涵盖了大部分耳熟能详的开源高阶组件的应用场景，如果你觉得这篇文章对你有启发，最好还是按照文章中的"),v("code",[e._v("demo")]),e._v("，跟着敲一遍，加深印象，知道什么场景用高阶组件，怎么用高阶组件。")]),e._v(" "),v("p",[v("code",[e._v("实践是检验真理的唯一标准")]),e._v("，希望大家能把高阶组件"),v("code",[e._v("码")]),e._v("起来，用起来。")])])}),[],!1,null,null,null);t.default=i.exports}}]);