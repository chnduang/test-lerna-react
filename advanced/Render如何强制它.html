<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>什么是 React 中的 Render 以及如何强制它？ | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.a427ee9b.css" as="style"><link rel="preload" href="/assets/js/app.c06c5691.js" as="script"><link rel="preload" href="/assets/js/2.e21ead49.js" as="script"><link rel="preload" href="/assets/js/9.af331656.js" as="script"><link rel="prefetch" href="/assets/js/10.b9a4c71a.js"><link rel="prefetch" href="/assets/js/11.f55d2255.js"><link rel="prefetch" href="/assets/js/12.fe15bcdc.js"><link rel="prefetch" href="/assets/js/13.87a3c5ce.js"><link rel="prefetch" href="/assets/js/14.ebf89fa4.js"><link rel="prefetch" href="/assets/js/15.cda0a8ba.js"><link rel="prefetch" href="/assets/js/16.f9dc23dc.js"><link rel="prefetch" href="/assets/js/17.84340ca0.js"><link rel="prefetch" href="/assets/js/18.bd273a95.js"><link rel="prefetch" href="/assets/js/19.81155919.js"><link rel="prefetch" href="/assets/js/20.9fd76e46.js"><link rel="prefetch" href="/assets/js/21.ace06104.js"><link rel="prefetch" href="/assets/js/22.90ade980.js"><link rel="prefetch" href="/assets/js/23.0666abd7.js"><link rel="prefetch" href="/assets/js/24.a72c373a.js"><link rel="prefetch" href="/assets/js/25.b969cb94.js"><link rel="prefetch" href="/assets/js/26.de056b27.js"><link rel="prefetch" href="/assets/js/27.c42084cb.js"><link rel="prefetch" href="/assets/js/28.4837174d.js"><link rel="prefetch" href="/assets/js/29.ff25f8d5.js"><link rel="prefetch" href="/assets/js/3.860eacbd.js"><link rel="prefetch" href="/assets/js/30.713760c5.js"><link rel="prefetch" href="/assets/js/31.7c617c61.js"><link rel="prefetch" href="/assets/js/32.d175bcfe.js"><link rel="prefetch" href="/assets/js/33.74590403.js"><link rel="prefetch" href="/assets/js/34.83533364.js"><link rel="prefetch" href="/assets/js/35.074e3e13.js"><link rel="prefetch" href="/assets/js/36.1ccfc83b.js"><link rel="prefetch" href="/assets/js/37.a396d472.js"><link rel="prefetch" href="/assets/js/38.db4bd748.js"><link rel="prefetch" href="/assets/js/39.df82dded.js"><link rel="prefetch" href="/assets/js/4.8f6f0475.js"><link rel="prefetch" href="/assets/js/40.c748e8b5.js"><link rel="prefetch" href="/assets/js/5.8b87f02a.js"><link rel="prefetch" href="/assets/js/6.2f86309f.js"><link rel="prefetch" href="/assets/js/7.f1cc41de.js"><link rel="prefetch" href="/assets/js/8.9c653580.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427ee9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  进阶
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  进阶
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/advanced/" aria-current="page" class="sidebar-link">进阶</a></li><li><a href="/advanced/Render如何强制它.html" class="active sidebar-link">什么是 React 中的 Render 以及如何强制它？</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>hoc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>keys</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/advanced/react-svelte入门.html" class="sidebar-link">写给 React 开发者看的 Svelte入门</a></li><li><a href="/advanced/react16常见api以及原理剖析.html" class="sidebar-link">react16常见api以及原理剖析</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>setstate</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/advanced/五分钟带你掌握优先队列.html" class="sidebar-link">五分钟带你掌握优先队列</a></li><li><a href="/advanced/前端架构之React领域驱动设计.html" class="sidebar-link">前端架构之 React 领域驱动设计</a></li><li><a href="/advanced/学好这些React设计模式.html" class="sidebar-link">学好这些React设计模式-能让你的 React 项目飞起来</a></li><li><a href="/advanced/浅谈React中的XSS攻击.html" class="sidebar-link">浅谈 React 中的 XSS 攻击</a></li><li><a href="/advanced/错误边界.html" class="sidebar-link">错误边界（Error Boundaries）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="什么是-react-中的-render-以及如何强制它"><a href="#什么是-react-中的-render-以及如何强制它" class="header-anchor">#</a> 什么是 React 中的 Render 以及如何强制它？</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/y3ByC1WSmhSabPo8yEQ6Dg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/y3ByC1WSmhSabPo8yEQ6Dg<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>React 中的 Render 究竟是什么，我们如何强制一个类或功能组件重新渲染，并且可以在不调用 setState 的情况下完成？</p> <p>是否可以强制 React 组件渲染（并且不调用 setState）？这个问题的简短回答是可以。但是，在我们了解如何操作之前，让我们先弄清楚一些重要的事情。</p> <p>从 React 的早期开始，开发人员就担心不必要的组件重新渲染并试图优化它们。我已经可以告诉你，过早优化并不是最好的主意，因为 React 非常快，而且问题通常出在代码的编写方式上。因此，当确实存在明显的问题时，请注意它。</p> <p>组件重新渲染的事实并不意味着实际上修改了 DOM。如果这对你来说是一个惊喜，那就忍受我吧。</p> <p>让我们先解释一下当我们在 React 中更新状态时到底发生了什么。</p> <h2 id="react-中的渲染是什么"><a href="#react-中的渲染是什么" class="header-anchor">#</a> <strong>React 中的渲染是什么？</strong></h2> <p>React 通过使用React.createElement函数来接管对 DOM 的操作，因此我们不必手动操作。相反，更新仅在需要时进行。</p> <p>我们只用 JSX 或纯createElement函数来描述我们希望 DOM 的外观，而 React 创建了 DOM 的虚拟表示。</p> <p>然后，在此基础上，每当状态改变后出现差异时，就会更新真实的 DOM。更重要的是，如果计划了很多 DOM 更新，React 可以将它们批处理以提高效率。尽管如此，整个过程包括三个阶段：渲染、协调和提交。</p> <p>渲染-呼叫作出反应渲染功能，从收集输出createElement功能和解-新元素对前面给出的元素进行比较，如果有差异的虚拟DOM更新，提交-真正的DOM更新。</p> <p>就像我之前提到的，改变状态并不意味着commit阶段会被执行，因为如果虚拟 DOM 没有改变就不需要它。</p> <p>正如你在下面的示例中看到的，无论我们单击按钮多少次，name属性都设置为相同的值，尽管我们调用了该setState方法。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// A simple exampleclass App extends Components {    state = {  name: ‘Thomas’}
  onClickHandler = () =&gt; {    this.setState({name: ‘Thomas’})}
  render() {    &lt;div&gt;      &lt;p&gt;My name is {this.state.name}&lt;/p&gt;&lt;br/&gt;      &lt;button onClick={this.onClickHandler}&gt;Click me&lt;/button&gt;    &lt;/div&gt;  }}
</code></pre></div><p>如果将控制台日志放入渲染函数中，你将看到它将被调用。但是，如果你在检查器中检查 DOM，你将不会看到指示 DOM 更改的闪烁。现在，让我们谈谈如何触发重新渲染。</p> <h2 id="在-react-中强制重新渲染组件"><a href="#在-react-中强制重新渲染组件" class="header-anchor">#</a> <strong>在 React 中强制重新渲染组件</strong></h2> <p>如果你使用的是 React 类组件，那么它就像使用this.forceUpdate()函数一样简单。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class App extends Components {    onClickHandler = () =&gt; {    this.forceUpdate()}
  render() {    &lt;button onClick={this.onClickHandler}&gt;Click me&lt;/button&gt;  }}
</code></pre></div><p>只需确保this上下文引用组件实例。</p> <p>在下面的示例中，this指的是React 组件实例的范围innerFunction的是 而不是范围，因此它不起作用。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// This won’t workclass App extends Components {    onClickHandler = () =&gt; {    function innerFunction() {      this.forceUpdate()    }    innerFunction()}
  render() {    &lt;button onClick={this.onClickHandler}&gt;Click me&lt;/button&gt;  }}
</code></pre></div><p>现在，你知道它是多么容易，但请注意，在 99.99% 的情况下你不应该需要它。如果你这样做，那么你可能做错了什么，并且可能有一个更好的解决方案来解决你想要实现的目标。</p> <p>如果你正在更新状态值，但它们没有正确呈现，那么你可能会直接改变当前状态而不是提供新值。你也有可能传递相同的引用。</p> <p>请记住，在更新状态时，应该始终提供一个新值。例如，字符串是不可变的；但是，对象和数组作为引用传递，因此：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// Equality check is done by checking if values are the sameconst str1 = ‘hello’const str2 = ‘hello’
str1 == str2  // true
// Equality check is performed by checking if values have the same referenceconst obj1 = {str: ‘hello’}const obj2 = {str: ‘hello’}const obj3 = obj1ob1 == obj2  // falseobj3 == obj1  // true
</code></pre></div><h2 id="在功能组件中强制重新渲染"><a href="#在功能组件中强制重新渲染" class="header-anchor">#</a> <strong>在功能组件中强制重新渲染</strong></h2> <p>在函数组件中没有forceUpdate方法。但是，我们可以使用以下代码模拟此功能。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React, {useState} from ‘react’
const App = props =&gt; {const [count, setCount] = useState(0)const onClickHandler = e = =&gt; {  setCount(prevCount =&gt; prevCount + 1)}
return (  &lt;button onClick={onClickHandler}&gt;Click me&lt;/button&gt;)}
</code></pre></div><p>如你所见，每当我们需要重新渲染组件时，我们只需增加计数器。老实说，我们可以走得更远，为它创建一个自定义钩子。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React, {useState} from ‘react’
const useForceUpdate = () =&gt; {  const [count, setCount] = useState(0)
  const increment = () =&gt; setCount(prevCount =&gt; prevCount + 1)  return [increment, count]}
const App = props =&gt; {const [forceUpdate] = useForceUpdate()
const onClickHandler = e =&gt; {  forceUpdate()}
return (  &lt;button onClick={onClickHandler}&gt;Click me&lt;/button&gt;)}
</code></pre></div><p>现在你已经了解了如何强制重新渲染组件。如果出于一些原因你想从父组件重新渲染子组件，那么，可以通过更改其 prop 来实现，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>const ChildComponent = props =&gt; {  return (    // child markup)}
const App = props =&gt; {  const [forceUpdate, forceUpdateValue] = useForceUpdate()
const onClickHandler = e =&gt; {  forceUpdate()}
return (  &lt;div&gt;    &lt;ChildComponent key={forceUpdateValue} /&gt;    &lt;button onClick={onClickHandler}&gt;Click me&lt;/button&gt;  &lt;/div&gt;)}
</code></pre></div><p>在本文中，我们介绍了 React 中什么是渲染，状态更新时会发生什么，以及如何在类和功能组件中强制重新渲染。</p> <p>最后一点，请记住，如果你认为需要强制重新渲染，请再想一想，可能有更好的方法。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/24/2022, 11:56:22 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/advanced/" class="prev router-link-active">
        进阶
      </a></span> <span class="next"><a href="/advanced/hoc/一文吃透React高阶组件HOC.html">
        一文吃透React高阶组件HOC
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.c06c5691.js" defer></script><script src="/assets/js/2.e21ead49.js" defer></script><script src="/assets/js/9.af331656.js" defer></script>
  </body>
</html>
