<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文吃透React高阶组件HOC | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.a427ee9b.css" as="style"><link rel="preload" href="/assets/js/app.c06c5691.js" as="script"><link rel="preload" href="/assets/js/2.e21ead49.js" as="script"><link rel="preload" href="/assets/js/10.b9a4c71a.js" as="script"><link rel="prefetch" href="/assets/js/11.f55d2255.js"><link rel="prefetch" href="/assets/js/12.fe15bcdc.js"><link rel="prefetch" href="/assets/js/13.87a3c5ce.js"><link rel="prefetch" href="/assets/js/14.ebf89fa4.js"><link rel="prefetch" href="/assets/js/15.cda0a8ba.js"><link rel="prefetch" href="/assets/js/16.f9dc23dc.js"><link rel="prefetch" href="/assets/js/17.84340ca0.js"><link rel="prefetch" href="/assets/js/18.bd273a95.js"><link rel="prefetch" href="/assets/js/19.81155919.js"><link rel="prefetch" href="/assets/js/20.9fd76e46.js"><link rel="prefetch" href="/assets/js/21.ace06104.js"><link rel="prefetch" href="/assets/js/22.90ade980.js"><link rel="prefetch" href="/assets/js/23.0666abd7.js"><link rel="prefetch" href="/assets/js/24.a72c373a.js"><link rel="prefetch" href="/assets/js/25.b969cb94.js"><link rel="prefetch" href="/assets/js/26.de056b27.js"><link rel="prefetch" href="/assets/js/27.c42084cb.js"><link rel="prefetch" href="/assets/js/28.4837174d.js"><link rel="prefetch" href="/assets/js/29.ff25f8d5.js"><link rel="prefetch" href="/assets/js/3.860eacbd.js"><link rel="prefetch" href="/assets/js/30.713760c5.js"><link rel="prefetch" href="/assets/js/31.7c617c61.js"><link rel="prefetch" href="/assets/js/32.d175bcfe.js"><link rel="prefetch" href="/assets/js/33.74590403.js"><link rel="prefetch" href="/assets/js/34.83533364.js"><link rel="prefetch" href="/assets/js/35.074e3e13.js"><link rel="prefetch" href="/assets/js/36.1ccfc83b.js"><link rel="prefetch" href="/assets/js/37.a396d472.js"><link rel="prefetch" href="/assets/js/38.db4bd748.js"><link rel="prefetch" href="/assets/js/39.df82dded.js"><link rel="prefetch" href="/assets/js/4.8f6f0475.js"><link rel="prefetch" href="/assets/js/40.c748e8b5.js"><link rel="prefetch" href="/assets/js/5.8b87f02a.js"><link rel="prefetch" href="/assets/js/6.2f86309f.js"><link rel="prefetch" href="/assets/js/7.f1cc41de.js"><link rel="prefetch" href="/assets/js/8.9c653580.js"><link rel="prefetch" href="/assets/js/9.af331656.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427ee9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  进阶
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  进阶
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/advanced/" aria-current="page" class="sidebar-link">进阶</a></li><li><a href="/advanced/Render如何强制它.html" class="sidebar-link">什么是 React 中的 Render 以及如何强制它？</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>hoc</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/advanced/hoc/一文吃透React高阶组件HOC.html" class="active sidebar-link">一文吃透React高阶组件HOC</a></li><li><a href="/advanced/hoc/从mixin到hoc再到hook-1.html" class="sidebar-link">从mixin到hoc再到hook-1</a></li><li><a href="/advanced/hoc/从mixin到hoc再到hook-2.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-2</a></li><li><a href="/advanced/hoc/从mixin到hoc再到hook-3.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-3</a></li><li><a href="/advanced/hoc/从mixin到hoc再到hook-4.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-4</a></li><li><a href="/advanced/hoc/说说对高阶组件的理解.html" class="sidebar-link">说说对高阶组件的理解？应用场景?</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>keys</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/advanced/react-svelte入门.html" class="sidebar-link">写给 React 开发者看的 Svelte入门</a></li><li><a href="/advanced/react16常见api以及原理剖析.html" class="sidebar-link">react16常见api以及原理剖析</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>setstate</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/advanced/五分钟带你掌握优先队列.html" class="sidebar-link">五分钟带你掌握优先队列</a></li><li><a href="/advanced/前端架构之React领域驱动设计.html" class="sidebar-link">前端架构之 React 领域驱动设计</a></li><li><a href="/advanced/学好这些React设计模式.html" class="sidebar-link">学好这些React设计模式-能让你的 React 项目飞起来</a></li><li><a href="/advanced/浅谈React中的XSS攻击.html" class="sidebar-link">浅谈 React 中的 XSS 攻击</a></li><li><a href="/advanced/错误边界.html" class="sidebar-link">错误边界（Error Boundaries）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一文吃透react高阶组件hoc"><a href="#一文吃透react高阶组件hoc" class="header-anchor">#</a> 一文吃透React高阶组件HOC</h1> <blockquote><p><a href="https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h1 id="一-前言"><a href="#一-前言" class="header-anchor">#</a> 一 前言</h1> <p><code>React</code>高阶组件(<code>HOC</code>)，对于很多<code>react</code>开发者来说并不陌生，它是灵活使用<code>react</code>组件的一种技巧，高阶组件本身不是组件，它是一个参数为组件，返回值也是一个组件的函数。高阶作用用于<strong>强化组件，复用逻辑，提升渲染性能等</strong>作用。高阶组件也并不是很难理解，其实接触过后还是蛮简单的，接下来我将按照，<strong>高阶组件理解？</strong>，<strong>高阶组件具体怎么使用？应用场景</strong>， <strong>高阶组件实践(源码级别)</strong> 为突破口，带大家详细了解一下高阶组件。本文篇幅比较长，建议收藏观看</p> <p>我们带着问题去开始今天的讨论：</p> <ul><li>1 什么是高阶组件，它解决了什么问题？</li> <li>2 有几种高阶组件，它们优缺点是什么？</li> <li>3 如何写一个优秀高阶组件？</li> <li>4 <code>hoc</code>怎么处理静态属性，跨层级<code>ref</code>等问题？</li> <li>5 高阶组件怎么控制渲染，隔离渲染？</li> <li>6 高阶组件怎么监控原始组件的状态？</li> <li>...</li></ul> <blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXvHqmbKib3PNgQiaxiaJ5dZYicz6nNNIzJR8beFsTUbDcvrh8hxSYMFGQXw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h1 id="二-全方位看高阶组件"><a href="#二-全方位看高阶组件" class="header-anchor">#</a> 二 全方位看高阶组件</h1> <h2 id="_1-几种包装强化组件的方式"><a href="#_1-几种包装强化组件的方式" class="header-anchor">#</a> 1 几种包装强化组件的方式</h2> <h3 id="_1-mixin模式"><a href="#_1-mixin模式" class="header-anchor">#</a> ① mixin模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXFKuSNPhezUhs2TNsfnfIjmeqFfqQdM6zcOxANCuNEcBwAaR928UtsQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="老版本的react-mixins"><a href="#老版本的react-mixins" class="header-anchor">#</a> 老版本的<code>react-mixins</code></h4> <p>在<code>react</code>初期提供一种组合方法。通过<code>React.createClass</code>,加入<code>mixins</code>属性，具体用法和<code>vue</code> 中<code>mixins</code>相似。具体实现如下。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const customMixin = {  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}
const APP = React.createClass({  mixins: [ customMixin ],  getInitialState(){    return {      name:'alien'    }  },  render(){    const { name  } = this.state    return &lt;div&gt; hello ,world , my name is { name } &lt;/div&gt;  }})
</code></pre></div><p>这种<code>mixins</code>只能存在<code>createClass</code>中，后来<code>React.createClass</code>连同<code>mixins</code>这种模式被废弃了。<code>mixins</code>会带来一些负面的影响。</p> <ul><li>1 mixin引入了隐式依赖关系。</li> <li>2 不同mixins之间可能会有先后顺序甚至代码冲突覆盖的问题</li> <li>3 mixin代码会导致滚雪球式的复杂性</li></ul> <h4 id="衍生方式"><a href="#衍生方式" class="header-anchor">#</a> 衍生方式</h4> <p><code>createClass</code>的废弃，不代表<code>mixin</code>模式退出<code>react</code>舞台，在有状态组件<code>class</code>，我们可以通过<strong>原型链继承</strong>来实现<code>mixins</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const customMixin = {  /* 自定义 mixins */  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}
function componentClassMixins(Component,mixin){ /* 继承 */  for(let key in mixin){    Component.prototype[key] = mixin[key]  }}
class Index extends React.Component{  constructor(){    super()    this.state={  name:'alien' }  }  render(){    return &lt;div&gt; hello,world      &lt;button onClick={ this.say.bind(this) } &gt; to say &lt;/button&gt;    &lt;/div&gt;  }}componentClassMixins(Index,customMixin)
</code></pre></div><h3 id="_2extends继承模式"><a href="#_2extends继承模式" class="header-anchor">#</a> ②extends继承模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXy6wIa4Xf7Sdop92zIlibRNia5ufhqNanetpjPSb4Kx5uvaBThWNicwpjw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>在<code>class</code>组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去<code>extends</code>我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Base extends React.Component{  constructor(){    super()    this.state={      name:'alien'    }  }  say(){    console.log('base components')  }  render(){    return &lt;div&gt; hello,world &lt;button onClick={ this.say.bind(this) } &gt;点击&lt;/button&gt;  &lt;/div&gt;  }}class Index extends Base{  componentDidMount(){    console.log( this.state.name )  }  say(){ /* 会覆盖基类中的 say  */    console.log('extends components')  }}export default Index
</code></pre></div><h3 id="_3hoc模式"><a href="#_3hoc模式" class="header-anchor">#</a> ③HOC模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXYs6OvOe4Jzm27Vl3bXG29H12prn2V3n5IicRuicMJJvUciagxmiamn5SPg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><code>HOC</code>是我们本章主要的讲的内容，具体用法，我们接下来会慢慢道来，我们先简单尝试一个<code>HOC</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(Component) {  return class wrapComponent extends React.Component{     constructor(){       super()       this.state={         name:'alien'       }     }     render=()=&gt;&lt;Component { ...this.props } { ...this.state } /&gt;  }}
@HOCclass Index extends React.Component{  say(){    const { name } = this.props    console.log(name)  }  render(){    return &lt;div&gt; hello,world &lt;button onClick={ this.say.bind(this) } &gt;点击&lt;/button&gt;  &lt;/div&gt;  }}
</code></pre></div><h3 id="_4自定义hooks模式"><a href="#_4自定义hooks模式" class="header-anchor">#</a> ④自定义hooks模式</h3> <p><strong>原型图</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><code>hooks</code>的诞生，一大部分原因是解决<strong>无状态组件没有<code>state</code>**和**逻辑难以复用</strong>问题。<code>hooks</code>可以将一段逻辑封装起来，做到开箱即用，我这里就不多讲了，接下来会出<code>react-hooks</code>原理的文章，完成<code>react-hooks</code>三部曲。感兴趣的同学可以看笔者的另外二篇文章，里面详细介绍了<code>react-hooks</code>复用代码逻辑的原则和方案。</p> <p>传送门：</p> <p>玩转react-hooks,自定义hooks设计模式及其实战</p> <p>react-hooks如何使用？</p> <h2 id="_2-高阶组件产生初衷"><a href="#_2-高阶组件产生初衷" class="header-anchor">#</a> 2 高阶组件产生初衷</h2> <p>组件是把<code>prop</code>渲染成<code>UI</code>,而高阶组件是将组件转换成另外一个组件，我们更应该注意的是，经过包装后的组件，获得了那些强化,节省多少逻辑，或是解决了原有组件的那些缺陷，这就是高阶组件的意义。我们先来思考一下高阶组件究竟解决了什么问题🤔🤔🤔？</p> <p><strong>① 复用逻辑</strong>：高阶组件更像是一个加工<code>react</code>组件的工厂，批量对原有组件进行<strong>加工</strong>，<strong>包装</strong>处理。我们可以根据业务需求定制化专属的<code>HOC</code>,这样可以解决复用逻辑。</p> <p><strong>② 强化props</strong>：这个是<code>HOC</code>最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的<code>props</code>,然后混入新的<code>props</code>,来增强组件的功能。代表作<code>react-router</code>中的<code>withRouter</code>。</p> <p><strong>③ 赋能组件</strong>：<code>HOC</code>有一项独特的特性，就是可以给被<code>HOC</code>包裹的业务组件，提供一些拓展功能，比如说<strong>额外的生命周期，额外的事件</strong>，但是这种<code>HOC</code>，可能需要和业务组件紧密结合。典型案例<code>react-keepalive-router</code>中的 <code>keepaliveLifeCycle</code>就是通过<code>HOC</code>方式，给业务组件增加了额外的生命周期。</p> <p><strong>④ 控制渲染</strong>：劫持渲染是<code>hoc</code>一个特性，在<code>wrapComponent</code>包装组件中，可以对原来的组件，进行<code>条件渲染</code>，<code>节流渲染</code>，<code>懒加载</code>等功能，后面会详细讲解，典型代表做<code>react-redux</code>中<code>connect</code>和 <code>dva</code>中 <code>dynamic</code> 组件懒加载。</p> <p>我会针对高阶组件的初衷展开，详细介绍其原理已经用法。跟上我的思路，我们先来看一下，高阶组件<strong>如何在我们的业务组件中使用的</strong>。</p> <h2 id="_3-高阶组件使用和编写结构"><a href="#_3-高阶组件使用和编写结构" class="header-anchor">#</a> 3 高阶组件使用和编写结构</h2> <p><code>HOC</code>使用指南是非常简单的，只需要将我们的组件进行包裹就可以了。</p> <h3 id="使用-装饰器模式和函数包裹模式"><a href="#使用-装饰器模式和函数包裹模式" class="header-anchor">#</a> 使用：装饰器模式和函数包裹模式</h3> <p>对于<code>class</code>声明的有状态组件，我们可以用装饰器模式，对类组件进行包装：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>@withStyles(styles)@withRouter@keepaliveLifeCycleclass Index extends React.Componen{    /* ... */}
</code></pre></div><p><strong>我们要注意一下包装顺序，越靠近<code>Index</code>组件的，就是越内层的<code>HOC</code>,离组件<code>Index</code>也就越近。</strong></p> <p>对于无状态组件(函数声明）我们可以这么写：</p> <ul><li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Index(){    /* .... */}export default withStyles(styles)(withRouter( keepaliveLifeCycle(Index) )) 
</code></pre></div><h3 id="模型-嵌套hoc"><a href="#模型-嵌套hoc" class="header-anchor">#</a> 模型：嵌套HOC</h3> <p>对于不需要传递参数的<code>HOC</code>，我们编写模型我们只需要嵌套一层就可以，比如<code>withRouter</code>,</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withRouter(){    return class wrapComponent extends React.Component{        /* 编写逻辑 */    }}
</code></pre></div><p>对于需要参数的<code>HOC</code>，我们需要一层代理，如下：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function connect (mapStateToProps){    /* 接受第一个参数 */    return function connectAdvance(wrapCompoent){        /* 接受组件 */        return class WrapComponent extends React.Component{  }    }}
</code></pre></div><p>我们看出两种<code>hoc</code>模型很简单，对于代理函数，可能有一层，可能有很多层，不过不要怕，无论多少层本质上都是一样的，我们只需要一层一层剥离开，分析结构，整个<code>hoc</code>结构和脉络就会清晰可见。吃透<code>hoc</code>也就易如反掌。</p> <h2 id="_4-两种不同的高阶组件"><a href="#_4-两种不同的高阶组件" class="header-anchor">#</a> 4 两种不同的高阶组件</h2> <p>常用的高阶组件有两种方式<strong>正向的属性代理</strong>和<strong>反向的组件继承</strong>，两者之前有一些共性和区别。接下具体介绍两者区别，在第三部分会详细介绍具体实现。</p> <h3 id="正向属性代理"><a href="#正向属性代理" class="header-anchor">#</a> 正向属性代理</h3> <p>所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。在<code>fiber tree</code> 上，先<code>mounted</code>代理组件，然后才是我们的业务组件。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(WrapComponent){    return class Advance extends React.Component{       state={           name:'alien'       }       render(){           return &lt;WrapComponent  { ...this.props } { ...this.state }  /&gt;       }    }}
</code></pre></div><h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>① 正常属性代理可以和业务组件低耦合，零耦合，对于<code>条件渲染</code>和<code>props属性增强</code>,只负责控制子组件渲染和传递额外的<code>props</code>就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的<code>hoc</code>，目前开源的<code>HOC</code>基本都是通过这个模式实现的。</li> <li>② 同样适用于<code>class</code>声明组件，和<code>function</code>声明的组件。</li> <li>③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免<code>反向继承</code>带来一些副作用，比如生命周期的执行。</li> <li>④ 可以嵌套使用，多个<code>hoc</code>是可以嵌套使用的，而且一般不会限制包装<code>HOC</code>的先后顺序。</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <ul><li>① 一般无法直接获取业务组件的状态，如果想要获取，需要<code>ref</code>获取组件实例。</li> <li>② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。</li></ul> <p><strong>例子：</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends React.Component{     render(){       return &lt;Component { ...this.props } { ...this.state } /&gt;     }  }}const newIndex =  HOC(Index) console.log(newIndex.say)
</code></pre></div><p><strong>打印结果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="反向继承"><a href="#反向继承" class="header-anchor">#</a> 反向继承</h3> <p>反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须在去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必要要知道当前</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}function HOC(Component){    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */
    }}export default HOC(Index)
</code></pre></div><h4 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h4> <ul><li><p>① 方便获取组件内部状态，比如<code>state</code>，<code>props</code> ,生命周期,绑定的事件函数等</p></li> <li><p>② <code>es6</code>继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。</p></li> <li><ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends Component{  }}const newIndex =  HOC(Index) console.log(newIndex.say)
</code></pre></div></li></ul> <p><strong>打印结果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h4> <ul><li>① 无状态组件无法使用。</li> <li>② 和被包装的组件强耦合，需要知道被包装的组件的内部状态，具体是做什么？</li> <li>③ 如果多个反向继承<code>hoc</code>嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个<code>componentDidMount</code>，当前<code>componentDidMount</code>会覆盖上一个<code>componentDidMount</code>。这样副作用串联起来，影响很大。</li></ul> <h1 id="三-如何编写高阶组件"><a href="#三-如何编写高阶组件" class="header-anchor">#</a> 三 如何编写高阶组件</h1> <p>接下来我们来看看，如何编写一个高阶组件，你可以参考如下的情景，去编写属于自己的<code>HOC</code>。</p> <h2 id="_1-强化props"><a href="#_1-强化props" class="header-anchor">#</a> 1 强化props</h2> <h3 id="_1-混入props"><a href="#_1-混入props" class="header-anchor">#</a> ① 混入props</h3> <p>这个是高阶组件最常用的功能，承接上层的<code>props</code>,在混入自己的<code>props</code>，来强化组件。</p> <p><strong>有状态组件(属性代理)</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function classHOC(WrapComponent){    return class  Idex extends React.Component{        state={            name:'alien'        }        componentDidMount(){           console.log('HOC')        }        render(){            return &lt;WrapComponent { ...this.props }  { ...this.state }   /&gt;        }    }}function Index(props){  const { name } = props  useEffect(()=&gt;{     console.log( 'index' )  },[])  return &lt;div&gt;    hello,world , my name is { name }  &lt;/div&gt;}
export default classHOC(Index)
</code></pre></div><p><strong>有状态组件(属性代理)</strong></p> <p>同样也适用与无状态组件。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function functionHoc(WrapComponent){    return function Index(props){        const [ state , setState ] = useState({ name :'alien'  })               return  &lt;WrapComponent { ...props }  { ...state }   /&gt;    }}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="_2-抽离state控制更新"><a href="#_2-抽离state控制更新" class="header-anchor">#</a> ② 抽离state控制更新</h3> <p>高阶组件可以将<code>HOC</code>的<code>state</code>的配合起来，控制业务组件的更新。这种用法在<code>react-redux</code>中<code>connect</code>高阶组件中用到过，用于处理来自<code>redux</code>中<code>state</code>更改，带来的订阅更新作用。</p> <p>我们将上述代码进行改造。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function classHOC(WrapComponent){  return class  Idex extends React.Component{      constructor(){        super()        this.state={          name:'alien'        }      }      changeName(name){        this.setState({ name })      }      render(){          return &lt;WrapComponent { ...this.props }  { ...this.state } changeName={this.changeName.bind(this)  }  /&gt;      }  }}function Index(props){  const [ value ,setValue ] = useState(null)  const { name ,changeName } = props  return &lt;div&gt;    &lt;div&gt;   hello,world , my name is { name }&lt;/div&gt;    改变name &lt;input onChange={ (e)=&gt; setValue(e.target.value)  }  /&gt;    &lt;button onClick={ ()=&gt;  changeName(value) }  &gt;确定&lt;/button&gt;  &lt;/div&gt;}
export default classHOC(Index)
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h2 id="_2-控制渲染"><a href="#_2-控制渲染" class="header-anchor">#</a> 2 控制渲染</h2> <p>控制渲染是高阶组件的一个很重要的特性，上边说到的两种高阶组件，都能完成对组件渲染的控制。具体实现还是有区别的，我们一起来探索一下。</p> <h3 id="_2-1-条件渲染"><a href="#_2-1-条件渲染" class="header-anchor">#</a> 2.1 条件渲染</h3> <h4 id="_1-基础-动态渲染"><a href="#_1-基础-动态渲染" class="header-anchor">#</a> ① 基础 ：动态渲染</h4> <p>对于属性代理的高阶组件，虽然不能在内部操控渲染状态，但是可以在外层控制当前组件是否渲染，这种情况应用于，<strong>权限隔离</strong>，<strong>懒加载</strong> ，<strong>延时加载</strong>等场景。</p> <p><strong>实现一个动态挂载组件的HOC</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function renderHOC(WrapComponent){  return class Index  extends React.Component{      constructor(props){        super(props)        this.state={ visible:true }        }      setVisible(){         this.setState({ visible:!this.state.visible })      }      render(){         const {  visible } = this.state          return &lt;div className=&quot;box&quot;  &gt;           &lt;button onClick={ this.setVisible.bind(this) } &gt; 挂载组件 &lt;/button&gt;           { visible ? &lt;WrapComponent { ...this.props } setVisible={ this.setVisible.bind(this) }   /&gt;  : &lt;div className=&quot;icon&quot; &gt;&lt;SyncOutlined spin  className=&quot;theicon&quot;  /&gt;&lt;/div&gt; }         &lt;/div&gt;      }  }}
class Index extends React.Component{  render(){    const { setVisible } = this.props    return &lt;div className=&quot;box&quot; &gt;        &lt;p&gt;hello,my name is alien&lt;/p&gt;        &lt;img  src='https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;fm=26&amp;gp=0.jpg'   /&gt;         &lt;button onClick={() =&gt; setVisible()}  &gt; 卸载当前组件 &lt;/button&gt;    &lt;/div&gt;  }}export default renderHOC(Index)
</code></pre></div><p>效果：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="_2-进阶-分片渲染"><a href="#_2-进阶-分片渲染" class="header-anchor">#</a> ② 进阶 ：分片渲染</h4> <p>是不是感觉不是很过瘾，为了让大家加强对<code>HOC</code>条件渲染的理解，我再做一个<strong>分片渲染+懒加载</strong>功能。为了让大家明白，我也是绞尽脑汁啊😂😂😂。</p> <p><strong>进阶：实现一个懒加载功能的HOC，可以实现组件的分片渲染,用于分片渲染页面，不至于一次渲染大量组件造成白屏效果</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const renderQueue = []let isFirstrender = false
const tryRender = ()=&gt;{  const render = renderQueue.shift()  if(!render) return  setTimeout(()=&gt;{    render() /* 执行下一段渲染 */  },300)} /* HOC */function renderHOC(WrapComponent){    return function Index(props){      const [ isRender , setRender ] = useState(false)      useEffect(()=&gt;{        renderQueue.push(()=&gt;{  /* 放入待渲染队列中 */          setRender(true)        })        if(!isFirstrender) {          tryRender() /**/          isFirstrender = true        }      },[])      return isRender ? &lt;WrapComponent tryRender={tryRender}  { ...props }  /&gt; : &lt;div className='box' &gt;&lt;div className=&quot;icon&quot; &gt;&lt;SyncOutlined   spin /&gt;&lt;/div&gt;&lt;/div&gt;    }}/* 业务组件 */class Index extends React.Component{  componentDidMount(){    const { name , tryRender} = this.props    /* 上一部分渲染完毕，进行下一部分渲染 */    tryRender()    console.log( name+'渲染')  }  render(){    return &lt;div&gt;        &lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; /&gt;    &lt;/div&gt;  }}/* 高阶组件包裹 */const Item = renderHOC(Index)
export default () =&gt; {  return &lt;React.Fragment&gt;      &lt;Item name=&quot;组件一&quot; /&gt;      &lt;Item name=&quot;组件二&quot; /&gt;      &lt;Item name=&quot;组件三&quot; /&gt;  &lt;/React.Fragment&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>大致流程，初始化的时候，<code>HOC</code>中将渲染真正组件的渲染函数，放入<code>renderQueue</code>队列中，然后初始化渲染一次，接下来，每一个项目组件，完成 <code>didMounted</code> 状态后，会从队列中取出下一个渲染函数，渲染下一个组件, 一直到所有的渲染任务全部执行完毕，渲染队列清空，有效的进行分片的渲染，这种方式对海量数据展示，很奏效。</p> <p>用<code>HOC</code>实现了条件渲染-分片渲染的功能，实际条件渲染理解起来很容易，就是通过变量，控制是否挂载组件，从而满足项目本身需求，条件渲染可以演变成很多模式，我这里介绍了条件渲染的二种方式，希望大家能够理解精髓所在。</p> <h4 id="_3-进阶-异步组件-懒加载"><a href="#_3-进阶-异步组件-懒加载" class="header-anchor">#</a> ③ 进阶：异步组件(懒加载)</h4> <p>不知道大家有没有用过<code>dva</code>,里面的<code>dynamic</code>就是应用<code>HOC</code>模式实现的组件异步加载，我这里简化了一下，提炼核心代码，如下：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>/* 路由懒加载HOC */export default function AsyncRouter(loadRouter) {  return class Content extends React.Component {    state = {Component: null}    componentDidMount() {      if (this.state.Component) return      loadRouter()        .then(module =&gt; module.default)        .then(Component =&gt; this.setState({Component},         ))    }    render() {      const {Component} = this.state      return Component ? &lt;Component {      ...this.props      }      /&gt; : null    }  }}
</code></pre></div><p>使用</p> <ul><li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const Index = AsyncRouter(()=&gt;import('../pages/index'))
</code></pre></div><p><code>hoc</code>还可以配合其他<code>API</code>，做一下衍生的功能。如上配合<code>import</code>实现异步加载功能。<code>HOC</code>用起来非常灵活，</p> <h4 id="_4-反向继承-渲染劫持"><a href="#_4-反向继承-渲染劫持" class="header-anchor">#</a> ④ 反向继承 ：渲染劫持</h4> <p><strong>HOC反向继承模式，可以实现颗粒化的渲染劫持，也就是可以控制基类组件的<code>render</code>函数，还可以篡改props，或者是<code>children</code>，我们接下来看看，这种状态下，怎么使用高阶组件。</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const HOC = (WrapComponent) =&gt;  class Index  extends WrapComponent {    render() {      if (this.props.visible) {        return super.render()      } else {        return &lt;div&gt;暂无数据&lt;/div&gt;      }    }  }
</code></pre></div><h4 id="_5-反向继承-修改渲染树"><a href="#_5-反向继承-修改渲染树" class="header-anchor">#</a> ⑤ 反向继承：修改渲染树</h4> <p><strong>修改渲染状态(劫持render替换子节点)</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt;       &lt;ul&gt;         &lt;li&gt;react&lt;/li&gt;         &lt;li&gt;vue&lt;/li&gt;         &lt;li&gt;Angular&lt;/li&gt;       &lt;/ul&gt;    &lt;/div&gt;  }}
function HOC (Component){  return class Advance extends Component {    render() {      const element = super.render()      const otherProps = {        name:'alien'      }      /* 替换 Angular 元素节点 */      const appendElement = React.createElement('li' ,{} , `hello ,world , my name  is ${ otherProps.name }` )      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=&gt;{           if(index === 2) return appendElement           return  child      })       return  React.cloneElement(element, element.props, newchild)    }  }}export  default HOC(Index)
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>我们用劫持渲染的方式，来操纵<code>super.render()</code>后的<code>React.element</code>元素，然后配合 <code>createElement</code> , <code>cloneElement</code> , <code>React.Children</code> 等 <code>api</code>,可以灵活操纵，真正的渲染<code>react.element</code>，可以说是偷天换日，不亦乐乎。</p> <h3 id="_2-2节流渲染"><a href="#_2-2节流渲染" class="header-anchor">#</a> 2.2节流渲染</h3> <p><code>hoc</code>除了可以进行<strong>条件渲染</strong>，<strong>渲染劫持</strong>功能外，还可以进行节流渲染，也就是可以优化性能，具体怎么做，请跟上我的节奏往下看。</p> <h4 id="_1-基础-节流原理"><a href="#_1-基础-节流原理" class="header-anchor">#</a> ① 基础: 节流原理</h4> <p><code>hoc</code>可以配合<code>hooks</code>的<code>useMemo</code>等<code>API</code>配合使用，可以实现对业务组件的渲染控制，减少渲染次数，从而达到优化性能的效果。如下案例，我们期望当且仅当<code>num</code>改变的时候，渲染组件，但是不影响接收的<code>props</code>。我们应该这样写我们的<code>HOC</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){     return function renderWrapComponent(props){       const { num } = props       const RenderElement = useMemo(() =&gt;  &lt;Component {...props}  /&gt; ,[ num ])       return RenderElement     }}class Index extends React.Component{  render(){     console.log(`当前组件是否渲染`,this.props)     return &lt;div&gt;hello,world, my name is alien &lt;/div&gt;  }}const IndexHoc = HOC(Index)
export default ()=&gt; {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return &lt;div&gt;        &lt;IndexHoc  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;button onClick={() =&gt; setNumber(num + 1) } &gt;num++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber1(num1 + 1) } &gt;num1++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber2(num2 + 1) } &gt;num2++&lt;/button&gt;    &lt;/div&gt;}
</code></pre></div><p><strong>效果：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>如图所示,当我们只有点击 <code>num++</code>时候，才重新渲染子组件，点击其他按钮，只是负责传递了<code>props</code>,达到了期望的效果。</p> <h4 id="_2-进阶-定制化渲染流"><a href="#_2-进阶-定制化渲染流" class="header-anchor">#</a> ② 进阶：定制化渲染流</h4> <p>思考：🤔上述的案例只是介绍了原理，在实际项目中，是量化生产不了的，原因是，我们需要针对不同<code>props</code>变化，写不同的<code>HOC</code>组件，这样根本起不了<code>Hoc</code>真正的用途，也就是<code>HOC</code>产生的初衷。所以我们需要对上述<code>hoc</code>进行改造升级，是组件可以根据定制化方向，去渲染组件。也就是<code>Hoc</code>生成的时候，已经按照某种契约去执行渲染。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (rule){     return function (Component){        return function renderWrapComponent(props){          const dep = rule(props)          const RenderElement = useMemo(() =&gt;  &lt;Component {...props}  /&gt; ,[ dep ])          return RenderElement        }     }}/* 只有 props 中 num 变化 ，渲染组件  */@HOC( (props)=&gt; props['num'])class IndexHoc extends React.Component{  render(){     console.log(`组件一渲染`,this.props)     return &lt;div&gt; 组件一 ：hello,world &lt;/div&gt;  }}
/* 只有 props 中 num1 变化 ，渲染组件  */@HOC((props)=&gt; props['num1'])class IndexHoc1 extends React.Component{  render(){     console.log(`组件二渲染`,this.props)     return &lt;div&gt; 组件二 ：my name is alien &lt;/div&gt;  }}export default ()=&gt; {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return &lt;div&gt;        &lt;IndexHoc  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;IndexHoc1  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;button onClick={() =&gt; setNumber(num + 1) } &gt;num++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber1(num1 + 1) } &gt;num1++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber2(num2 + 1) } &gt;num2++&lt;/button&gt;    &lt;/div&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>完美实现了效果。这用高阶组件模式，可以灵活控制<code>React</code>组件层面上的，<strong><code>props</code>数据流</strong>和<strong>更新流</strong>，优秀的高阶组件有 <code>mobx</code> 中<code>observer</code> ,<code>inject</code> , <code>react-redux</code>中的<code>connect</code>,感兴趣的同学，可以抽时间研究一下。</p> <h2 id="_3-赋能组件"><a href="#_3-赋能组件" class="header-anchor">#</a> 3 赋能组件</h2> <p>高阶组件除了上述两种功能之外，还可以赋能组件，比如加一些<strong>额外<code>生命周期</code></strong>，<strong>劫持事件</strong>，<strong>监控日志</strong>等等。</p> <h3 id="_3-1-劫持原型链-劫持生命周期-事件函数"><a href="#_3-1-劫持原型链-劫持生命周期-事件函数" class="header-anchor">#</a> 3.1 劫持原型链-劫持生命周期，事件函数</h3> <h4 id="_1-属性代理实现"><a href="#_1-属性代理实现" class="header-anchor">#</a> ① 属性代理实现</h4> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return class wrapComponent extends React.Component{      render(){        return &lt;Component {...this.props}  /&gt;      }  }}@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return &lt;div&gt;hello,world&lt;/div&gt;   }}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="_2-反向继承实现"><a href="#_2-反向继承实现" class="header-anchor">#</a> ② 反向继承实现</h4> <p>反向继承，因为在继承原有组件的基础上，可以对原有组件的<strong>生命周期</strong>或<strong>事件</strong>进行劫持，甚至是替换。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const didMount = Component.prototype.componentDidMount  return class wrapComponent extends Component{      componentDidMount(){        console.log('------劫持生命周期------')        if (didMount) {           didMount.apply(this) /* 注意 `this` 指向问题。*/        }      }      render(){        return super.render()      }  }}
@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return &lt;div&gt;hello,world&lt;/div&gt;   }}
</code></pre></div><h3 id="_3-2-事件监控"><a href="#_3-2-事件监控" class="header-anchor">#</a> 3.2 事件监控</h3> <p><code>HOC</code>还可以对原有组件进行监控。比如对一些<code>事件监控</code>，<code>错误监控</code>，<code>事件监听</code>等一系列操作。</p> <h4 id="_1-组件内的事件监听"><a href="#_1-组件内的事件监听" class="header-anchor">#</a> ① 组件内的事件监听</h4> <p>接下来，我们做一个<code>HOC</code>,只对组件内的点击事件做一个监听效果。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function ClickHoc (Component){  return  function Wrap(props){    const dom = useRef(null)    useEffect(()=&gt;{     const handerClick = () =&gt; console.log('发生点击事件')      dom.current.addEventListener('click',handerClick)     return () =&gt; dom.current.removeEventListener('click',handerClick)    },[])    return  &lt;div ref={dom}  &gt;&lt;Component  {...props} /&gt;&lt;/div&gt;  }}
@ClickHocclass Index extends React.Component{   render(){     return &lt;div  className='index'  &gt;       &lt;p&gt;hello，world&lt;/p&gt;       &lt;button&gt;组件内部点击&lt;/button&gt;    &lt;/div&gt;   }}export default ()=&gt;{  return &lt;div className='box'  &gt;     &lt;Index /&gt;     &lt;button&gt;组件外部点击&lt;/button&gt;  &lt;/div&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="_3-ref助力操控组件实例"><a href="#_3-ref助力操控组件实例" class="header-anchor">#</a> 3 ref助力操控组件实例</h3> <p>对于属性代理我们虽然不能直接获取组件内的状态，但是我们可以通过<code>ref</code>获取组件实例,获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：<code>class</code>声明的有状态组件才有实例，<code>function</code>声明的无状态组件不存在实例。</p> <h4 id="_1-属性代理-添加额外生命周期"><a href="#_1-属性代理-添加额外生命周期" class="header-anchor">#</a> ① 属性代理-添加额外生命周期</h4> <p>我们可以针对某一种情况, 给组件增加额外的生命周期，我做了一个简单的<code>demo</code>，监听<code>number</code>改变，如果<code>number</code>改变，就自动触发组件的监听函数<code>handerNumberChange</code>。具体写法如下</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Hoc(Component){  return class WrapComponent extends React.Component{      constructor(){        super()        this.node = null      }      UNSAFE_componentWillReceiveProps(nextprops){          if(nextprops.number !== this.props.number ){            this.node.handerNumberChange  &amp;&amp;  this.node.handerNumberChange.call(this.node)          }      }      render(){        return &lt;Component {...this.props} ref={(node) =&gt; this.node = node }  /&gt;      }  }}@Hocclass Index extends React.Component{  handerNumberChange(){      /* 监听 number 改变 */  }  render(){    return &lt;div&gt;hello,world&lt;/div&gt;  }}
</code></pre></div><p>这种写法有点不尽人意，大家不要着急，在第四部分，源码实战中，我会介绍一种更好的场景。方便大家理解<code>Hoc</code>对原有组件的赋能。</p> <h2 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4 总结</h2> <p>上面我分别按照<code>hoc</code>主要功能，<strong>强化props</strong> ， <strong>控制渲染</strong> ，<strong>赋能组件</strong> 三个方向对<code>HOC</code>编写做了一个详细介绍，和应用场景的介绍，目的<strong>让大家在理解高阶组件的时候，更明白什么时候会用到？,怎么样去写？`</strong> 里面涵盖的知识点我总一个总结。</p> <p>对于属性代理HOC，我们可以：</p> <ul><li>强化props &amp; 抽离state。</li> <li>条件渲染，控制渲染，分片渲染，懒加载。</li> <li>劫持事件和生命周期</li> <li>ref控制组件实例</li> <li>添加事件监听器，日志</li></ul> <p>对于反向代理的HOC,我们可以：</p> <ul><li>劫持渲染，操纵渲染树</li> <li>控制/替换生命周期，直接获取组件状态，绑定事件。</li></ul> <p>每个应用场景，我都举了例子🌰🌰，大家可以结合例子深入了解一下其原理和用途。</p> <h1 id="四-高阶组件源码级实践"><a href="#四-高阶组件源码级实践" class="header-anchor">#</a> 四 高阶组件源码级实践</h1> <p><code>hoc</code>的应用场景有很多，也有很多好的开源项目，供我们学习和参考，接下来我真对三个方向上的功能用途，分别从源码角度解析<code>HOC</code>的用途。</p> <h2 id="_1-强化prop-withroute"><a href="#_1-强化prop-withroute" class="header-anchor">#</a> 1 强化prop- withRoute</h2> <p>用过<code>withRoute</code>的同学，都明白其用途，<code>withRoute</code>用途就是，对于没有被<code>Route</code>包裹的组件，给添加<code>history</code>对象等和路由相关的状态，方便我们在任意组件中，都能够获取路由状态，进行路由跳转，这个<code>HOC</code>目的很清楚，就是强化<code>props</code>,把<code>Router</code>相关的状态都混入到<code>props</code>中，我们看看具体怎么实现的。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withRouter(Component) {  const displayName = `withRouter(${Component.displayName || Component.name})`;  const C = props =&gt; {      /*  获取 */    const { wrappedComponentRef, ...remainingProps } = props;    return (      &lt;RouterContext.Consumer&gt;        {context =&gt; {          return (            &lt;Component              {...remainingProps}              {...context}              ref={wrappedComponentRef}            /&gt;          );        }}      &lt;/RouterContext.Consumer&gt;    );  };
  C.displayName = displayName;  C.WrappedComponent = Component;  /* 继承静态属性 */  return hoistStatics(C, Component);}
export default withRouter
</code></pre></div><p><code>withRoute</code>的流程实际很简单，就是先从<code>props</code>分离出<code>ref</code>和<code>props</code>,然后从存放整个<code>route</code>对象上下文<code>RouterContext</code>取出<code>route</code>对象,然后混入到原始组件的<code>props</code>中，最后用<code>hoistStatics</code>继承静态属性。至于<code>hoistStatics</code>我们稍后会讲到。</p> <h2 id="_2-控制渲染案例-connect"><a href="#_2-控制渲染案例-connect" class="header-anchor">#</a> 2 控制渲染案例 connect</h2> <p>由于<code>connect</code>源码比较长和难以理解，所以我们提取精髓，精简精简再精简, 总结的核心功能如下,<code>connect</code>的作用也有<code>合并props</code>，但是更重要的是接受<code>state</code>，来控制更新组件。下面这个代码中，为了方便大家理解，我都给简化了。希望大家能够理解<code>hoc</code>如何<strong>派发</strong>和<strong>控制</strong>更新流的。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import store from './redux/store'import { ReactReduxContext } from './Context'import { useContext } from 'react'function connect(mapStateToProps){   /* 第一层：接收订阅state函数 */    return function wrapWithConnect (WrappedComponent){        /* 第二层：接收原始组件 */        function ConnectFunction(props){            const [ , forceUpdate ] = useState(0)            const { reactReduxForwardedRef ,...wrapperProps } = props                        /* 取出Context */            const { store } = useContext(ReactReduxContext)
            /* 强化props：合并 store state 和 props  */            const trueComponentProps = useMemo(()=&gt;{                  /* 只有props或者订阅的state变化，才返回合并后的props */                 return selectorFactory(mapStateToProps(store.getState()),wrapperProps)             },[ store , wrapperProps ])
            /* 只有 trueComponentProps 改变时候,更新组件。*/            const renderedWrappedComponent = useMemo(              () =&gt; (                &lt;WrappedComponent                  {...trueComponentProps}                  ref={reactReduxForwardedRef}                /&gt;              ),              [reactReduxForwardedRef, WrappedComponent, trueComponentProps]            )            useEffect(()=&gt;{              /* 订阅更新 */               const checkUpdate = () =&gt; forceUpdate(new Date().getTime())               store.subscribe( checkUpdate )            },[ store ])            return renderedWrappedComponent        }        /* React.memo 包裹  */        const Connect = React.memo(ConnectFunction)
        /* 处理hoc,获取ref问题 */          if(forwardRef){          const forwarded = React.forwardRef(function forwardConnectRef( props,ref) {            return &lt;Connect {...props} reactReduxForwardedRef={ref} reactReduxForwardedRef={ref} /&gt;          })          return hoistStatics(forwarded, WrappedComponent)        }         /* 继承静态属性 */        return hoistStatics(Connect,WrappedComponent)    } }export default Index
</code></pre></div><p><code>connect</code> 涉及到的功能点还真不少呢，首先第一层接受订阅函数，第二层接收原始组件，然后用<code>forwardRef</code>处理<code>ref</code>,用<code>hoistStatics</code> 处理静态属性的继承，在包装组件内部，合并<code>props</code>,<code>useMemo</code>缓存原始组件，只有合并后的<code>props</code>发生变化，才更新组件，然后在<code>useEffect</code>内部通过<code>store.subscribe()</code>订阅更新。这里省略了<code>Subscription</code>概念，真正的<code>connect</code>中有一个<code>Subscription</code>专门负责订阅消息。</p> <h2 id="_3-赋能组件-缓存生命周期-keepalivelifecycle"><a href="#_3-赋能组件-缓存生命周期-keepalivelifecycle" class="header-anchor">#</a> 3 赋能组件-缓存生命周期 keepaliveLifeCycle</h2> <p>之前笔者写了一个<code>react</code>缓存页面的开源库<code>react-keepalive-router</code>，可以实现<code>vue</code>中 <code>keepalive</code> + <code>router</code>功能，最初的版本没有缓存周期的，但是后来热心读者，期望在被缓存的路由组件中加入缓存周期，类似<code>activated</code>这种的，后来经过我的分析打算用<code>HOC</code>来实现此功能。</p> <p>于是乎<code>react-keepalive-router</code>加入了全新的页面组件生命周期 <code>actived</code> 和 <code>unActived</code>, <code>actived</code> 作为缓存路由组件激活时候用，初始化的时候会默认执行一次 , <code>unActived</code> 作为路由组件缓存完成后调用。但是生命周期需要用一个 <code>HOC</code> 组件<code>keepaliveLifeCycle</code> 包裹。</p> <p>使用</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React   from 'react'import { keepaliveLifeCycle } from 'react-keepalive-router'
@keepaliveLifeCycleclass index extends React.Component&lt;any,any&gt;{
    state={        activedNumber:0,        unActivedNumber:0    }    actived(){        this.setState({            activedNumber:this.state.activedNumber + 1        })    }    unActived(){        this.setState({            unActivedNumber:this.state.unActivedNumber + 1        })    }    render(){        const { activedNumber , unActivedNumber } = this.state        return &lt;div  style={{ marginTop :'50px' }}  &gt;           &lt;div&gt; 页面 actived 次数：{activedNumber} &lt;/div&gt;           &lt;div&gt; 页面 unActived 次数：{unActivedNumber} &lt;/div&gt;        &lt;/div&gt;    }}export default index
</code></pre></div><p>**
**</p> <p><strong>原理</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import {lifeCycles} from '../core/keeper'import hoistNonReactStatic from 'hoist-non-react-statics'function keepaliveLifeCycle(Component) {   class Hoc extends React.Component {    cur = null    handerLifeCycle = type =&gt; {      if (!this.cur) return      const lifeCycleFunc = this.cur[type]      isFuntion(lifeCycleFunc) &amp;&amp; lifeCycleFunc.call(this.cur)    }    componentDidMount() {       const {cacheId} = this.props      cacheId &amp;&amp; (lifeCycles[cacheId] = this.handerLifeCycle)    }    componentWillUnmount() {      const {cacheId} = this.props      delete lifeCycles[cacheId]    }     render=() =&gt; &lt;Component {...this.props} ref={cur =&gt; (this.cur = cur)}/&gt;  }  return hoistNonReactStatic(Hoc,Component)}
</code></pre></div><p><code>keepaliveLifeCycle</code> 的原理很简单，就是通过<code>ref</code>或获取 <code>class</code> 组件的实例,在 <code>hoc</code> 初始化时候<strong>进行生命周期的绑定</strong>, 在 <code>hoc</code> 销毁阶段，对生命周期进行解绑, 然后交给<code>keeper</code>统一调度，<code>keeper</code>通过调用实例下面的生命周期函数，来实现缓存生命周期功能的。</p> <h1 id="五-高阶组件的注意事项"><a href="#五-高阶组件的注意事项" class="header-anchor">#</a> 五 高阶组件的注意事项</h1> <h2 id="_1-谨慎修改原型链"><a href="#_1-谨慎修改原型链" class="header-anchor">#</a> 1 谨慎修改原型链</h2> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return  Component}
</code></pre></div><p>这样做会产生一些不良后果。比如如果你再用另一个同样会修改 <code>componentDidMount</code> 的 <code>HOC</code> 增强它，那么前面的 <code>HOC</code> 就会失效！同时，这个 <code>HOC</code> 也无法应用于没有生命周期的函数组件。</p> <h2 id="_2-继承静态属性"><a href="#_2-继承静态属性" class="header-anchor">#</a> 2 继承静态属性</h2> <p>在用属性代理的方式编写<code>HOC</code>的时候，要注意的是就是，静态属性丢失的问题，前面提到了，如果不做处理，静态方法就会全部丢失。</p> <h3 id="手动继承"><a href="#手动继承" class="header-anchor">#</a> 手动继承</h3> <p>我们可以手动将原始组件的静态方法<code>copy</code>到 <code>hoc</code>组件上来，但前提是必须准确知道应该拷贝哪些方法。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  // 必须准确知道应该拷贝哪些方法   WrappedComponent.staticMethod = Component.staticMethod  return WrappedComponent}
</code></pre></div><h3 id="引入第三方库"><a href="#引入第三方库" class="header-anchor">#</a> 引入第三方库</h3> <p>这样每个静态方法都绑定会很累，尤其对于开源的<code>hoc</code>，<strong>对原生组件的静态方法是未知的</strong>,我们可以使用 <code>hoist-non-react-statics</code> 自动拷贝所有的静态方法:</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import hoistNonReactStatic from 'hoist-non-react-statics'function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  hoistNonReactStatic(WrappedComponent,Component)  return WrappedComponent}
</code></pre></div><h2 id="_3-跨层级捕获ref"><a href="#_3-跨层级捕获ref" class="header-anchor">#</a> 3 跨层级捕获ref</h2> <p>高阶组件的约定是将所有 <code>props</code> 传递给被包装组件，但这对于 <code>refs</code> 并不适用。那是因为 <code>ref</code> 实际上并不是一个 <code>prop</code> - 就像 <code>key</code> 一样，它是由 <code>React</code> 专门处理的。如果将 <code>ref</code> 添加到 <code>HOC</code> 的返回组件中，则 <code>ref</code> 引用指向容器组件，而不是被包装组件。我们可以通过<code>forwardRef</code>来解决这个问题。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>/** *  * @param {*} Component 原始组件 * @param {*} isRef  是否开启ref模式 */function HOC(Component,isRef){  class Wrap extends React.Component{     render(){        const { forwardedRef ,...otherprops  } = this.props        return &lt;Component ref={forwardedRef}  {...otherprops}  /&gt;     }  }    if(isRef){      return  React.forwardRef((props,ref)=&gt; &lt;Wrap forwardedRef={ref} {...props} /&gt; )    }    return Wrap}
class Index extends React.Component{  componentDidMount(){      console.log(666)  }  render(){    return &lt;div&gt;hello,world&lt;/div&gt;  }}
const HocIndex =  HOC(Index,true)
export default ()=&gt;{  const node = useRef(null)  useEffect(()=&gt;{     /* 就可以跨层级，捕获到 Index 组件的实例了 */     console.log(node.current.componentDidMount)  },[])  return &lt;div&gt;&lt;HocIndex ref={node}  /&gt;&lt;/div&gt;}
</code></pre></div><p><strong>打印结果：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>如上就解决了,<code>HOC</code>跨层级捕获<code>ref</code>的问题。</p> <h2 id="_4-render中不要声明hoc"><a href="#_4-render中不要声明hoc" class="header-anchor">#</a> 4 render中不要声明HOC</h2> <p>🙅错误写法：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){     const WrapHome = HOC(Home)     return &lt;WrapHome /&gt;  }}
</code></pre></div><p>如果这么写，会造成一个极大的问题，因为每一次<code>HOC</code>都会返回一个新的<code>WrapHome</code>,<code>react diff</code>会判定两次<strong>不是同一个组件</strong>，那么每次<code>Index</code> 组件 <code>render</code>触发，<code>WrapHome</code>，会重新挂载，状态会<strong>全都丢失</strong>。如果想要动态绑定<code>HOC</code>,请参考如下方式。</p> <p>🙆正确写法：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const WrapHome = HOC(Home)class index extends React.Component{  render(){     return &lt;WrapHome /&gt;  }}
</code></pre></div><h1 id="六-总结"><a href="#六-总结" class="header-anchor">#</a> 六 总结</h1> <p>本文从高阶组件功能为切入点，介绍二种不同的高阶组件如何编写，应用场景，以及实践。涵盖了大部分耳熟能详的开源高阶组件的应用场景，如果你觉得这篇文章对你有启发，最好还是按照文章中的<code>demo</code>，跟着敲一遍，加深印象，知道什么场景用高阶组件，怎么用高阶组件。</p> <p><code>实践是检验真理的唯一标准</code>，希望大家能把高阶组件<code>码</code>起来，用起来。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/24/2022, 11:56:22 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/advanced/Render如何强制它.html" class="prev">
        什么是 React 中的 Render 以及如何强制它？
      </a></span> <span class="next"><a href="/advanced/hoc/从mixin到hoc再到hook-1.html">
        从mixin到hoc再到hook-1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.c06c5691.js" defer></script><script src="/assets/js/2.e21ead49.js" defer></script><script src="/assets/js/10.b9a4c71a.js" defer></script>
  </body>
</html>
