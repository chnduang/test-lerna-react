<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Deep In React 之详谈 React 16 Diff 策略(二) | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.a427ee9b.css" as="style"><link rel="preload" href="/assets/js/app.c06c5691.js" as="script"><link rel="preload" href="/assets/js/2.e21ead49.js" as="script"><link rel="preload" href="/assets/js/30.713760c5.js" as="script"><link rel="prefetch" href="/assets/js/10.b9a4c71a.js"><link rel="prefetch" href="/assets/js/11.f55d2255.js"><link rel="prefetch" href="/assets/js/12.fe15bcdc.js"><link rel="prefetch" href="/assets/js/13.87a3c5ce.js"><link rel="prefetch" href="/assets/js/14.ebf89fa4.js"><link rel="prefetch" href="/assets/js/15.cda0a8ba.js"><link rel="prefetch" href="/assets/js/16.f9dc23dc.js"><link rel="prefetch" href="/assets/js/17.84340ca0.js"><link rel="prefetch" href="/assets/js/18.bd273a95.js"><link rel="prefetch" href="/assets/js/19.81155919.js"><link rel="prefetch" href="/assets/js/20.9fd76e46.js"><link rel="prefetch" href="/assets/js/21.ace06104.js"><link rel="prefetch" href="/assets/js/22.90ade980.js"><link rel="prefetch" href="/assets/js/23.0666abd7.js"><link rel="prefetch" href="/assets/js/24.a72c373a.js"><link rel="prefetch" href="/assets/js/25.b969cb94.js"><link rel="prefetch" href="/assets/js/26.de056b27.js"><link rel="prefetch" href="/assets/js/27.c42084cb.js"><link rel="prefetch" href="/assets/js/28.4837174d.js"><link rel="prefetch" href="/assets/js/29.ff25f8d5.js"><link rel="prefetch" href="/assets/js/3.860eacbd.js"><link rel="prefetch" href="/assets/js/31.7c617c61.js"><link rel="prefetch" href="/assets/js/32.d175bcfe.js"><link rel="prefetch" href="/assets/js/33.74590403.js"><link rel="prefetch" href="/assets/js/34.83533364.js"><link rel="prefetch" href="/assets/js/35.074e3e13.js"><link rel="prefetch" href="/assets/js/36.1ccfc83b.js"><link rel="prefetch" href="/assets/js/37.a396d472.js"><link rel="prefetch" href="/assets/js/38.db4bd748.js"><link rel="prefetch" href="/assets/js/39.df82dded.js"><link rel="prefetch" href="/assets/js/4.8f6f0475.js"><link rel="prefetch" href="/assets/js/40.c748e8b5.js"><link rel="prefetch" href="/assets/js/5.8b87f02a.js"><link rel="prefetch" href="/assets/js/6.2f86309f.js"><link rel="prefetch" href="/assets/js/7.f1cc41de.js"><link rel="prefetch" href="/assets/js/8.9c653580.js"><link rel="prefetch" href="/assets/js/9.af331656.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427ee9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fiber/" class="nav-link router-link-active">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fiber/" class="nav-link router-link-active">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/fiber/" aria-current="page" class="sidebar-link">Fiber</a></li><li><a href="/fiber/React-Fiber架构浅析.html" class="sidebar-link">React-Fiber架构浅析</a></li><li><a href="/fiber/ReactFiber是如何实现更新过程可控的.html" class="sidebar-link">React Fiber 是如何实现更新过程可控的</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>diff</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fiber/diff/diff.html" aria-current="page" class="active sidebar-link">Deep In React 之详谈 React 16 Diff 策略(二)</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dom</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>keys</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/fiber/从中断机制看ReactFiber技术.html" class="sidebar-link">从中断机制看 React Fiber 技术</a></li><li><a href="/fiber/六个问题让你更懂ReactFiber.html" class="sidebar-link">六个问题让你更懂 React Fiber</a></li><li><a href="/fiber/理解其原理fiber.html" class="sidebar-link">手写React的Fiber架构，深入理解其原理</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="deep-in-react-之详谈-react-16-diff-策略-二"><a href="#deep-in-react-之详谈-react-16-diff-策略-二" class="header-anchor">#</a> Deep In React 之详谈 React 16 Diff 策略(二)</h2> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是<strong>为了提高代码的可维护性</strong>，而<strong>不是为了提高性能</strong>的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。具体可以参考我公众号以前发的这两篇文章：</p> <ul><li><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ" target="_blank" rel="noopener noreferrer">别再说虚拟 DOM 快了，要被打脸的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A" target="_blank" rel="noopener noreferrer">深入理解虚拟 DOM，它真的不快<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>如果你对标题不满意，请把文章看完，至少也得把文章最后的结论好好看下</p></blockquote> <p>在上一篇将 React Fiber 架构中，已经说到过，React 现在将整体的数据结构从树改为了链表结构。所以相应的 Diff 算法也得改变，以为以前的 Diff 算法就是基于树的。</p> <p>老的 Diff 算法提出了三个策略来保证整体界面构建的性能，具体是：</p> <ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li> <li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li> <li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol> <p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。</p> <p>具体老的算法可以见这篇文章：<a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener noreferrer">React 源码剖析系列 － 不可思议的 react diff<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>说实话，老的 Diff 算法还是挺复杂的，你仅仅看上面这篇文章估计一时半会都不能理解，更别说看源码了。对于 React 16 的 Diff 算法(我觉得都不能把它称作算法，最多叫个 Diff 策略)其实还是蛮简单的，React 16 是整个调度流程感觉比较难，我在前面将 Fiber 的文章已经简单的梳理过了，后面也会慢慢的逐个攻破。</p> <p>接下来就开始正式的讲解 React 16 的 Diff 策略吧！</p> <h2 id="diff-简介"><a href="#diff-简介" class="header-anchor">#</a> Diff 简介</h2> <p><strong>做 Diff 的目的就是为了复用节点。</strong></p> <p>链表的每一个节点是 Fiber，而不是在 16 之前的虚拟DOM 节点。</p> <blockquote><p>我这里说的虚拟 DOM 节点是指 React.createElement 方法所产生的节点。虚拟 DOM tree 只维护了组件状态以及组件与 DOM 树的关系，Fiber Node 承载的东西比 虚拟 DOM 节点多很多。</p></blockquote> <p>Diff 就是新旧节点的对比，在<a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A" target="_blank" rel="noopener noreferrer">上一篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中也说道了，这里面的 Diff 主要是构建 currentInWorkProgress 的过程，同时得到 Effect List，给下一个阶段 commit 做准备。</p> <p>React16 的 diff 策略采用从链表头部开始比较的算法，是<strong>层次遍历</strong>，算法是建立在一个节点的插入、删除、移动等操作都是在节点树的<strong>同一层级</strong>中进行的。</p> <p>对于 Diff， 新老节点的对比，我们以新节点为标准，然后来构建整个 currentInWorkProgress，对于新的 children 会有四种情况。</p> <ul><li>TextNode(包含字符串和数字)</li> <li>单个 React Element(通过该节点是否有 $$typeof 区分)</li> <li>数组</li> <li>可迭代的 children，跟数组的处理方式差不多</li></ul> <p>那么我们就来一步一步的看这四种类型是如何进行 diff 的。</p> <h2 id="前置知识介绍"><a href="#前置知识介绍" class="header-anchor">#</a> 前置知识介绍</h2> <p>这篇文章主要是从 React 的源码的逻辑出发介绍的，所以介绍之前了解下只怎么进入到这个 diff 函数的，react 的 diff 算法是从 <code>reconcileChildren</code> 开始的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">nextChildren</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">renderExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderExpirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      current<span class="token punctuation">.</span>child<span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderExpirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>reconcileChildren</code> 只是一个入口函数，如果首次渲染，current 空 null，就通过 <code>mountChildFibers</code> 创建子节点的 Fiber 实例。如果不是首次渲染，就调用 <code>reconcileChildFibers</code>去做 diff，然后得出 effect list。</p> <p>接下来再看看 mountChildFibers 和 reconcileChildFibers 有什么区别：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> reconcileChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> mountChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>他们都是通过 <code>ChildReconciler</code> 函数来的，只是传递的参数不同而已。这个参数叫<code>shouldTrackSideEffects</code>，他的作用是判断是否要增加一些<code>effectTag</code>，主要是用来优化初次渲染的，因为初次渲染没有更新操作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">newChild</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token comment">// 主要的 Diff 逻辑</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>reconcileChildFibers</code> 就是 Diff 部分的主体代码，这个函数超级长，是一个包装函数，下面所有的 diff 代码都在这里面，详细的源码注释可以见<a href="https://github.com/crazylxr/deep-in-react/blob/master/analysis/06-rencocilerChildren.md" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p><strong>参数介绍</strong></p> <ul><li><code>returnFiber</code> 是即将 Diff 的这层的父节点。</li> <li><code>currentFirstChild</code>是当前层的第一个 Fiber 节点。</li> <li><code>newChild</code> 是即将更新的 vdom 节点(可能是 TextNode、可能是 ReactElement，可能是数组)，不是 Fiber 节点</li> <li><code>expirationTime</code> 是过期时间，这个参数是跟调度有关系的，本系列还没讲解，当然跟 Diff 也没有关系。</li></ul> <blockquote><p>再次提醒，reconcileChildFibers 是 reconcile(diff) 的一层。</p></blockquote> <p>前置知识介绍完毕，就开始详细介绍每一种节点是如何进行 Diff 的。</p> <h2 id="diff-textnode"><a href="#diff-textnode" class="header-anchor">#</a> Diff TextNode</h2> <p>首先看 TextNode，因为它是最简单的，担心直接看到难的，然后就打击你的信心。</p> <p>看下面两个小 demo：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// demo1：当前 ui 对应的节点的 jsx</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token comment">// ...</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>xxx<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>xxx<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>xxx<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>xxx<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token comment">//...</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>

<span class="token comment">// demo2：更新成功后的节点对应的 jsx</span>

<span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token comment">// ...</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          前端桃园
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token comment">//...</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre></div><p>对应的单链表结构图：</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134126.png" alt="image-20190714223931338"></p> <p>对于 diff TextNode 会有两种情况。</p> <ol><li>currentFirstNode 是 TextNode</li> <li>currentFirstNode 不是 TextNode</li></ol> <blockquote><p>currentFirstNode 是当前该层的第一个节点，reconcileChildFibers 传进来的参数。</p></blockquote> <p>**为什么要分两种情况呢？**原因就是为了复用节点</p> <p><strong>第一种情况</strong>。xxx 是一个 TextNode，那么就代表这这个节点可以复用，有复用的节点，对性能优化很有帮助。既然新的 child 只有一个 TextNode，那么复用节点之后，就把剩下的 aaa 节点就可以删掉了，那么 div 的 child 就可以添加到 workInProgress 中去了。</p> <p>源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>currentFirstChild <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentFirstChild<span class="token punctuation">.</span>tag <span class="token operator">===</span> HostText<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// We already have an existing node so let's just update it and delete</span>
      <span class="token comment">// the rest.</span>
      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>currentFirstChild<span class="token punctuation">,</span> textContent<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
      existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
      <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在源码里 <code>useFiber</code> 就是复用节点的方法，<code>deleteRemainingChildren</code> 就是删除剩余节点的方法，这里是从 <code>currentFirstChild.sibling</code> 开始删除的。</p> <p>**第二种情况。**xxx 不是一个 TextNode，那么就代表这个节点不能复用，所以就从 <code>currentFirstChild</code>开始删掉剩余的节点，对应到上面的图中就是删除掉 xxx 节点和 aaa 节点。</p> <p>对于源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromText</span><span class="token punctuation">(</span>
    textContent<span class="token punctuation">,</span>
    returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
</code></pre></div><p>其中 <code>createFiberFromText</code> 就是根据 <code>textContent</code> 来创建节点的方法。</p> <blockquote><p>注意：删除节点不会真的从链表里面把节点删除，只是打一个 delete 的 tag，当 commit 的时候才会真正的去删除。</p></blockquote> <h2 id="diff-react-element"><a href="#diff-react-element" class="header-anchor">#</a> Diff React Element</h2> <p>有了上面 TextNode 的 Diff 经验，那么来理解 React Element 的 Diff 就比较简单了，因为他们的思路是一致的：先找有没有可以复用的节点，如果没有就另外创建一个。</p> <p>那么就有一个问题，<strong>如何判断这个节点是否可以复用呢？</strong></p> <p>有两个点：1. key 相同。 2. 节点的类型相同。</p> <p>如果以上两点相同，就代表这个节点只是变化了内容，不需要创建新的节点，可以复用的。</p> <p>对应的源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    child<span class="token punctuation">.</span>tag <span class="token operator">===</span> Fragment
    <span class="token operator">?</span> element<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span>
    <span class="token operator">:</span> child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> element<span class="token punctuation">.</span>type
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为什么要删除老的节点的兄弟节点？</span>
    <span class="token comment">// 因为当前节点是只有一个节点，而老的如果是有兄弟节点是要删除的，是多于的。删掉了之后就可以复用老的节点了</span>
    <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 复用当前节点</span>
    <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>
      child<span class="token punctuation">,</span>
      element<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span>
      <span class="token operator">?</span> element<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children
      <span class="token operator">:</span> element<span class="token punctuation">.</span>props<span class="token punctuation">,</span>
      expirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    existing<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相信这些代码都很好理解了，除了判断条件跟前面 TextNode 的判断条件不一样，其余的基本都一样，只是 React Element 多了一个跟新 ref 的过程。</p> <p>同样，如果节点的类型不相同，就将节点从当前节点开始把剩余的都删除。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>到这里，可能你们就会觉得接下来应该就是讲解当没有可以复用的节点的时候是如果创建节点的。</p> <p>不过可惜你们猜错了。因为 Facebook 的工程师很厉害，另外还做了一个工作来优化，来找到复用的节点。</p> <p>我们现在来看这种情况：</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134319.jpg" alt="image-20190714232052778"></p> <p>这种情况就是有可能更新的时候删除了一个节点，但是另外的节点还留着。</p> <p>那么在对比 xxx 节点和 AAA 节点的时候，它们的节点类型是不一样，按照我们上面的逻辑，还是应该把 xxx 和 AAA 节点删除，然后创建一个 AAA 节点。</p> <p>但是你看，明明 xxx 的 slibling 有一个 AAA 节点可以复用，但是被删了，多浪费呀。所以还有另外有一个策略来找 xxx 的所有兄弟节点中有没有可以复用的节点。</p> <p>这种策略就是从 div 下面的所有子节点去找有没有可以复用的节点，而不是像 TextNode 一样，只是找第一个 child 是否可以复用，如果当前节点的 key 不同，就代表肯定不是同一个节点，所以把当前节点删除，然后再去找当前节点的兄弟节点，直到找到 key 相同，并且节点的类型相同，否则就删除所有的子节点。</p> <blockquote><p>你有木有这样的问题：为什么 TextNode 不采用这样的循环策略来找可以复用的节点呢？这个问题留给你思考，欢迎在评论区留下你的答案。</p></blockquote> <p>对应的源码逻辑如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 找到 key 相同的节点，就会复用当前节点</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      child<span class="token punctuation">.</span>tag <span class="token operator">===</span> Fragment
      <span class="token operator">?</span> element<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span>
      <span class="token operator">:</span> child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> element<span class="token punctuation">.</span>type
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 复用节点逻辑，省略该部分代码，和上面复用节点的代码相同</span>
      <span class="token comment">// code ...</span>
      <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有可以复用的节点，就把这个节点删除</span>
    <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面这段代码我们需要注意的是，当 key 相同，React 会认为是同一个节点，所以当 key 相同，节点类型不同的时候，React 会认为你已经把这个节点重新覆盖了，所以就不会再去找剩余的节点是否可以复用。只有在 key 不同的时候，才会去找兄弟节点是否可以复用。</p> <p>接下来才是我们前面说的，如果没有找到可以复用的节点，然后就重新创建节点，源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 前面的循环已经把该删除的已经删除了，接下来就开始创建新的节点了</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromFragment</span><span class="token punctuation">(</span>
    element<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    element<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
  <span class="token keyword">return</span> created<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromElement</span><span class="token punctuation">(</span>
    element<span class="token punctuation">,</span>
    returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
  <span class="token keyword">return</span> created<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于 Fragment 节点和一般的 Element 节点创建的方式不同，因为 Fragment 本来就是一个无意义的节点，他真正需要创建 Fiber 的是它的 children，而不是它自己，所以 <code>createFiberFromFragment</code> 传递的不是 <code>element</code>，而是 <code>element.props.children</code>。</p> <h2 id="diff-array"><a href="#diff-array" class="header-anchor">#</a> Diff Array</h2> <p>Diff Array 算是 Diff 中最难的一部分了，比较的复杂，因为做了很多的优化，不过请你放心，认真看完我的讲解，最难的也会很容易理解，废话不多说，开始吧！</p> <p>因为 Fiber 树是单链表结构，没有子节点数组这样的数据结构，也就没有可以供两端同时比较的尾部游标。所以React的这个算法是一个简化的两端比较法，只从头部开始比较。</p> <p>前面已经说了，Diff 的目的就是为了复用，对于 Array 就不能像之前的节点那样，仅仅对比一下元素的 key 或者 元素类型就行，因为数组里面是好多个元素。你可以在头脑里思考两分钟如何进行复用节点，再看 React 是怎么做的，然后对比一下孰优孰劣。</p> <h3 id="_1-相同位置-index-进行比较"><a href="#_1-相同位置-index-进行比较" class="header-anchor">#</a> 1. 相同位置(index)进行比较</h3> <p>相同位置进行对比，这个是比较容易想到的一种方式，还是举个例子加深一下印象。</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134317.jpg" alt="image-20190721212259855"></p> <p>这已经是一个非常简单的例子了，div 的 child 是一个数组，有 AAA、BBB 然后还有其他的兄弟节点，在做 diff 的时候就可以从新旧的数组中按照索引一一对比，如果可以复用，就把这个节点从老的链表里面删除，不能复用的话再进行其他的复用策略。</p> <p>那如果判断节点是否可以复用呢？有了前面的 ReactElement 和 TextNode 复用的经验，这个也类似，因为是一一对比嘛，相当于是一个节点一个节点的对比。</p> <p>不过对于 newChild 可能会有很多种类型，简单的看下源码是如何进行判断的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token keyword">const</span> key <span class="token operator">=</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> oldFiber<span class="token punctuation">.</span>key <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>前面的经验可得，判断是否可以复用，常常会根据 key 是否相同来决定，所以首先获取了老节点的 key 是否存在。如果不存在老节点很可能是 TextNode 或者是 Fragment。</p> <p>接下来再看 newChild 为不同类型的时候是如何进行处理的。</p> <p><strong>当 newChild 是 TextNode 的时候</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对于新的节点如果是 string 或者 number，那么都是没有 key 的，</span>
  <span class="token comment">// 所有如果老的节点有 key 的话，就不能复用，直接返回 null。</span>
  <span class="token comment">// 老的节点 key 为 null 的话，代表老的节点是文本节点，就可以复用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">updateTextNode</span><span class="token punctuation">(</span>
    returnFiber<span class="token punctuation">,</span>
    oldFiber<span class="token punctuation">,</span>
    <span class="token string">''</span> <span class="token operator">+</span> newChild<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果 key 不为 null，那么就代表老节点不是 TextNode，而新节点又是 TextNode，所以返回 null，不能复用，反之则可以复用，调用 <code>updateTextNode</code> 方法。</p> <blockquote><p>注意，updateTextNode 里面包含了首次渲染的时候的逻辑，首次渲染的时候回插入一个 TextNode，而不是复用。</p></blockquote> <p><strong>当 newChild 是 Object 的时候</strong></p> <p>newChild 是 Object 的时候基本上走的就是 ReactElement 的逻辑了，判断 key 和 元素的类型是否相等来判断是否可以复用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 有 $$typeof 代表就是 ReactElement</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token comment">// ReactElement 的逻辑 </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> <span class="token constant">REACT_PORTAL_TYPE</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token comment">// 调用 updatePortal</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">getIteratorFn</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">updateFragment</span><span class="token punctuation">(</span>
      returnFiber<span class="token punctuation">,</span>
      oldFiber<span class="token punctuation">,</span>
      newChild<span class="token punctuation">,</span>
      expirationTime<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先判断是否是对象，用的是 <code>typeof newChild === 'object' &amp;&amp; newChild !== null</code> ，注意要加 <code>!== null</code>，因为 <code>typeof null</code> 也是 object。</p> <p>然后通过 $$typeof 判断是 REACT_ELEMENT_TYPE 还是 REACT_PORTAL_TYPE，分别调用不同的复用逻辑，然后由于数组也是 Object ，所以这个 if 里面也有数组的复用逻辑。</p> <p>我相信到这里应该对于应该对于如何相同位置的节点如何对比有清晰的认识了。另外还有问题，那就是如何循环一个一个对比呢？</p> <p>这里要注意，新的节点的 children 是虚拟 DOM，所以这个 children 是一个数组，而对于之前提到的老的节点树是链表。</p> <p>那么循环一个一个对比，就是遍历数组的过程。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> newIdx <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 新数组的索引</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历老的节点</span>
  nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span> 
  <span class="token comment">// 返回复用节点的函数，newFiber 就是复用的节点。</span>
  <span class="token comment">// 如果为空，就代表同位置对比已经不能复用了，循环结束。</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateSlot</span><span class="token punctuation">(</span>
    returnFiber<span class="token punctuation">,</span>
    oldFiber<span class="token punctuation">,</span>
    newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 其他 code，比如删除复用的节点</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这并不是源码的全部源码，我只是把思路给贴出来了。</p> <p>这是第一次遍历新数组，通过调用 <code>updateSlot</code> 来对比新老元素，前面介绍的如何对比新老节点的代码都是在这个函数里。这个循环会把所以的从前面开始能复用的节点，都复用到。比如上面我们画的图，如果两个链表里面的 **？？？**节点，不相同，那么 newFiber 为 null，这个循环就会跳出。</p> <p>跳出来了，就会有两种情况。</p> <ul><li>新节点已经遍历完毕</li> <li>老节点已经遍历完毕</li></ul> <h3 id="_2-新节点已经遍历完毕"><a href="#_2-新节点已经遍历完毕" class="header-anchor">#</a> 2. 新节点已经遍历完毕</h3> <p>如果新节点已经遍历完毕的话，也就是没有要更新的了，这种情况一般就是从原来的数组里面删除了元素，那么直接把剩下的老节点删除了就行了。还是拿上面的图的例子举例，老的链表里**？？？<strong>还有很多节点，而新的链表</strong>？？？<strong>已经没有节点了，所以老的链表</strong>？？？**不管是有多少节点，都不能复用了，所以没用了，直接删除。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>newIdx <span class="token operator">===</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 新的 children 长度已经够了，所以把剩下的删除掉</span>
  <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意这里是直接 <code>return</code> 了哦，没有继续往下执行了。</p> <h3 id="_3-老节点已经遍历完毕"><a href="#_3-老节点已经遍历完毕" class="header-anchor">#</a> 3. 老节点已经遍历完毕</h3> <p>如果老的节点在第一次循环的时候就被复用完了，新的节点还有，很有可能就是新增了节点的情况。那么这个时候只需要根据把剩余新的节点直接创建 <strong>Fiber</strong> 就行了。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果老的节点已经被复用完了，对剩下的新节点进行操作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">createChild</span><span class="token punctuation">(</span>
      returnFiber<span class="token punctuation">,</span>
      newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>
      expirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>oldFiber === null</code> 就是用来判断老的 Fiber 节点变量完了的代码，Fiber 链表是一个单向链表，所以为 null 的时候代表已经结束了。所以就直接把剩余的 newChild 通过循环创建 Fiber。</p> <p>到这里，目前简单的对数组进行增、删节点的对比还是比较简单，接下来就是移动的情况是如何进行复用的呢？</p> <h3 id="_4-移动的情况如何进行节点复用"><a href="#_4-移动的情况如何进行节点复用" class="header-anchor">#</a> 4. 移动的情况如何进行节点复用</h3> <p>对于移动的情况，首先要思考，怎么能判断数组是否发生过移动操作呢？</p> <p>如果给你两个数组，你是否能判断出来数组是否发生过移动。</p> <p>答案是：老的数组和新的数组里面都有这个元素，而且位置不相同。</p> <p>从两个数组中找到相同元素(是指可复用的节点)，方法有很多种，来看看 React 是如何高效的找出来的。</p> <p><strong>把所有老数组元素按 key 或者是 index 放 Map 里，然后遍历新数组，根据新数组的 key 或者 index 快速找到老数组里面是否有可复用的。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>
 <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
 <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">existingChildren</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> existingChild <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span> <span class="token comment">// currentFirstChild 是老数组链表的第一个元素</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>existingChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 看到这里可能会疑惑怎么在 Map 里面的key 是 fiber 的key 还是 fiber 的 index 呢？</span>
  <span class="token comment">// 我觉得是根据数据类型，fiber 的key 是字符串，而 index 是数字，这样就能区分了</span>
  <span class="token comment">// 所以这里是用的 map，而不是对象，如果是对象的key 就不能区分 字符串类型和数字类型了。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>key <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      existingChildren<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>key<span class="token punctuation">,</span> existingChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      existingChildren<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>index<span class="token punctuation">,</span> existingChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    existingChild <span class="token operator">=</span> existingChild<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> existingChildren<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 <code>mapRemainingChildren</code> 就是将老数组存放到 Map 里面。元素有 key 就 Map 的键就存 key，没有 key 就存 index，key 一定是字符串，index 一定是 number，所以取的时候是能区分的，所以这里用的是 Map，而不是对象，如果是对象，属性是字符串，就没办法区别是 key 还是 index 了。</p> <p>现在有了这个 Map，剩下的就是循环新数组，找到 Map 里面可以复用的节点，如果找不到就创建，这个逻辑基本上跟 <code>updateSlot</code> 的复用逻辑很像，一个是从老数组链表中获取节点对比，一个是从 Map 里获取节点对比。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 如果前面的算法有复用，那么 newIdx 就不从 0 开始</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateFromMap</span><span class="token punctuation">(</span>
    existingChildren<span class="token punctuation">,</span>
    returnFiber<span class="token punctuation">,</span>
    newIdx<span class="token punctuation">,</span>
    newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 省略删除 existingChildren 中的元素和添加 Placement 副作用的情况</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到这里新数组遍历完毕，也就是<strong>同一层</strong>的 Diff 过程完毕，接下来进行总结一下。</p> <h3 id="效果演示"><a href="#效果演示" class="header-anchor">#</a> 效果演示</h3> <p>以下效果动态演示来自于文章：<a href="https://slane.cn/2018/08/09/react-diff-yuan-ma-fen-xi/" target="_blank" rel="noopener noreferrer">React Diff 源码分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，我觉得这个演示非常的形象，有助于理解。</p> <p>这里渲染一个可输入的数组。
<img src="http://imgs.taoweng.site/2019-07-28-134128.png" alt="1"></p> <p>当第一种情况，新数组遍历完了，老数组剩余直接删除（12345→1234 删除 5）：</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134130.gif" alt="img"></p> <p>新数组没完，老数组完了（1234→1234567 插入 567）：</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134136.gif" alt="img"></p> <p>移动的情况，即之前就存在这个元素，后续只是顺序改变（123 → 4321 插入4，移动2 1）：</p> <p><img src="http://imgs.taoweng.site/2019-07-28-134140.gif" alt="img"></p> <p>最后删除没有涉及的元素。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>对于数组的 diff 策略，相对比较复杂，最后来梳理一下这个策略，其实还是很简单，只是看源码的时候比较难懂。</p> <p>我们可以把整个过程分为三个阶段：</p> <ol><li>第一遍历新数组，新老数组相同 index 进行对比，通过 <code>updateSlot</code>方法找到可以复用的节点，直到找到不可以复用的节点就退出循环。</li> <li>第一遍历完之后，删除剩余的老节点，追加剩余的新节点的过程。如果是新节点已遍历完成，就将剩余的老节点批量删除；如果是老节点遍历完成仍有新节点剩余，则将新节点直接插入。</li> <li>把所有老数组元素按 key 或 index 放 Map 里，然后遍历新数组，插入老数组的元素，这是移动的情况。</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/24/2022, 11:56:22 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fiber/ReactFiber是如何实现更新过程可控的.html" class="prev">
        React Fiber 是如何实现更新过程可控的
      </a></span> <span class="next"><a href="/fiber/dom/React是如何创建-vdom和fiber-tree.html">
        React 是如何创建 vdom和fibertree
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.c06c5691.js" defer></script><script src="/assets/js/2.e21ead49.js" defer></script><script src="/assets/js/30.713760c5.js" defer></script>
  </body>
</html>
